// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1pl9qdv(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1s56lr9(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  UIEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external UIEdgeInsets _NativeLibrary_protocolTrampoline_1rtilx3(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  objc.CGRect Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external objc.CGRect _NativeLibrary_protocolTrampoline_szn7s6(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external bool _NativeLibrary_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

/// WARNING: NSUserActivity is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
extension type NSUserActivity._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSUserActivity',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUserActivity',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

final class CGContext extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

sealed class UIRectEdge {
  static const UIRectEdgeNone = 0;
  static const UIRectEdgeTop = 1;
  static const UIRectEdgeLeft = 2;
  static const UIRectEdgeBottom = 4;
  static const UIRectEdgeRight = 8;
  static const UIRectEdgeAll = 15;
}

final class UIEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;
}

final class NSDirectionalEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double leading;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double trailing;
}

sealed class UIRectCorner {
  static const UIRectCornerTopLeft = 1;
  static const UIRectCornerTopRight = 2;
  static const UIRectCornerBottomLeft = 4;
  static const UIRectCornerBottomRight = 8;
  static const UIRectCornerAllCorners = -1;
}

enum UIColorProminence {
  UIColorProminencePrimary(0),
  UIColorProminenceSecondary(1),
  UIColorProminenceTertiary(2),
  UIColorProminenceQuaternary(3);

  final int value;
  const UIColorProminence(this.value);

  static UIColorProminence fromValue(int value) => switch (value) {
    0 => UIColorProminencePrimary,
    1 => UIColorProminenceSecondary,
    2 => UIColorProminenceTertiary,
    3 => UIColorProminenceQuaternary,
    _ => throw ArgumentError('Unknown value for UIColorProminence: $value'),
  };
}

/// WARNING: UIColor is a stub. To generate bindings for this class, include
/// UIColor in your config's objc-interfaces list.
///
/// UIColor
extension type UIColor._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [UIColor] that points to the same underlying object as [other].
  UIColor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIColor] that wraps the given raw object pointer.
  UIColor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }
}

/// WARNING: UIImage is a stub. To generate bindings for this class, include
/// UIImage in your config's objc-interfaces list.
///
/// UIImage
extension type UIImage._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [UIImage] that points to the same underlying object as [other].
  UIImage.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImage', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIImage] that wraps the given raw object pointer.
  UIImage.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImage', iOS: (false, (2, 0, 0)));
  }
}

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
    -1 => NSWritingDirectionNatural,
    0 => NSWritingDirectionLeftToRight,
    1 => NSWritingDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for NSWritingDirection: $value'),
  };
}

final class CATransform3D extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;
}

/// WARNING: CALayerDelegate is a stub. To generate bindings for this class, include
/// CALayerDelegate in your config's objc-protocols list.
///
/// CALayerDelegate
extension type CALayerDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [CALayerDelegate] that points to the same underlying object as [other].
  CALayerDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CALayerDelegate] that wraps the given raw object pointer.
  CALayerDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UIMenuElementState {
  UIMenuElementStateOff(0),
  UIMenuElementStateOn(1),
  UIMenuElementStateMixed(2);

  final int value;
  const UIMenuElementState(this.value);

  static UIMenuElementState fromValue(int value) => switch (value) {
    0 => UIMenuElementStateOff,
    1 => UIMenuElementStateOn,
    2 => UIMenuElementStateMixed,
    _ => throw ArgumentError('Unknown value for UIMenuElementState: $value'),
  };
}

sealed class UIMenuElementAttributes {
  static const UIMenuElementAttributesDisabled = 1;
  static const UIMenuElementAttributesDestructive = 2;
  static const UIMenuElementAttributesHidden = 4;
  static const UIMenuElementAttributesKeepsMenuPresented = 8;
}

enum UIMenuElementRepeatBehavior {
  UIMenuElementRepeatBehaviorAutomatic(0),
  UIMenuElementRepeatBehaviorRepeatable(1),
  UIMenuElementRepeatBehaviorNonRepeatable(2);

  final int value;
  const UIMenuElementRepeatBehavior(this.value);

  static UIMenuElementRepeatBehavior fromValue(int value) => switch (value) {
    0 => UIMenuElementRepeatBehaviorAutomatic,
    1 => UIMenuElementRepeatBehaviorRepeatable,
    2 => UIMenuElementRepeatBehaviorNonRepeatable,
    _ => throw ArgumentError(
      'Unknown value for UIMenuElementRepeatBehavior: $value',
    ),
  };
}

/// WARNING: UIEvent is a stub. To generate bindings for this class, include
/// UIEvent in your config's objc-interfaces list.
///
/// UIEvent
extension type UIEvent._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIEvent] that points to the same underlying object as [other].
  UIEvent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIEvent] that wraps the given raw object pointer.
  UIEvent.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }
}

/// WARNING: UIPasteConfigurationSupporting$1 is a stub. To generate bindings for this class, include
/// UIPasteConfigurationSupporting in your config's objc-protocols list.
///
/// UIPasteConfigurationSupporting
extension type UIPasteConfigurationSupporting$1._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIPasteConfigurationSupporting$1] that points to the same underlying object as [other].
  UIPasteConfigurationSupporting$1.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIPasteConfigurationSupporting$1] that wraps the given raw object pointer.
  UIPasteConfigurationSupporting$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIUserActivityRestoring is a stub. To generate bindings for this class, include
/// UIUserActivityRestoring in your config's objc-protocols list.
///
/// UIUserActivityRestoring
extension type UIUserActivityRestoring._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIUserActivityRestoring] that points to the same underlying object as [other].
  UIUserActivityRestoring.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIUserActivityRestoring] that wraps the given raw object pointer.
  UIUserActivityRestoring.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
abstract final class ObjCBlock_NSDictionary_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
  fromFunction(
    objc.NSDictionary Function(objc.NSDictionary) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        objc.NSDictionary.fromPointer(arg0, retain: true, release: true),
      ).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
extension ObjCBlock_NSDictionary_NSDictionary$CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> {
  objc.NSDictionary call(objc.NSDictionary arg0) =>
      objc.NSDictionary.fromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObjectImpl> arg0,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObjectImpl>,
              )
            >()(ref.pointer, arg0.ref.pointer),
        retain: true,
        release: true,
      );
}

/// WARNING: UIResponderStandardEditActions is a stub. To generate bindings for this class, include
/// UIResponderStandardEditActions in your config's objc-protocols list.
///
/// UIResponderStandardEditActions
extension type UIResponderStandardEditActions._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIResponderStandardEditActions] that points to the same underlying object as [other].
  UIResponderStandardEditActions.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIResponderStandardEditActions] that wraps the given raw object pointer.
  UIResponderStandardEditActions.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _class_UIResponder = objc.getClass("UIResponder");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_keyCommands = objc.registerName("keyCommands");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// UIResponderKeyCommands
extension UIResponderKeyCommands on UIResponder {
  /// keyCommands
  objc.NSArray? get keyCommands {
    objc.checkOsVersionInternal(
      'UIResponder.keyCommands',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keyCommands);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_UIView = objc.getClass("UIView");
late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setFrame_ = objc.registerName("setFrame:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_bounds = objc.registerName("bounds");
late final _sel_setBounds_ = objc.registerName("setBounds:");
late final _sel_center = objc.registerName("center");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setCenter_ = objc.registerName("setCenter:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();
late final _sel_transform = objc.registerName("transform");
final _objc_msgSend_5qswvj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        CGAffineTransform Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      CGAffineTransform Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_5qswvjStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CGAffineTransform>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<CGAffineTransform>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTransform_ = objc.registerName("setTransform:");
final _objc_msgSend_qgt66z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          CGAffineTransform,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        CGAffineTransform,
      )
    >();
late final _sel_transform3D = objc.registerName("transform3D");
final _objc_msgSend_5qlg3j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        CATransform3D Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      CATransform3D Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_5qlg3jStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CATransform3D>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<CATransform3D>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTransform3D_ = objc.registerName("setTransform3D:");
final _objc_msgSend_1s50tpz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          CATransform3D,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        CATransform3D,
      )
    >();
late final _sel_contentScaleFactor = objc.registerName("contentScaleFactor");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setContentScaleFactor_ = objc.registerName(
  "setContentScaleFactor:",
);
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_anchorPoint = objc.registerName("anchorPoint");
late final _sel_setAnchorPoint_ = objc.registerName("setAnchorPoint:");
late final _sel_isMultipleTouchEnabled = objc.registerName(
  "isMultipleTouchEnabled",
);
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setMultipleTouchEnabled_ = objc.registerName(
  "setMultipleTouchEnabled:",
);
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_isExclusiveTouch = objc.registerName("isExclusiveTouch");
late final _sel_setExclusiveTouch_ = objc.registerName("setExclusiveTouch:");
late final _sel_hitTest_withEvent_ = objc.registerName("hitTest:withEvent:");
final _objc_msgSend_u7nfz8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_pointInside_withEvent_ = objc.registerName(
  "pointInside:withEvent:",
);
final _objc_msgSend_yvwe5y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertPoint_toView_ = objc.registerName(
  "convertPoint:toView:",
);
final _objc_msgSend_3l1tu1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_3l1tu1Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertPoint_fromView_ = objc.registerName(
  "convertPoint:fromView:",
);
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");
final _objc_msgSend_2olghr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_2olghrStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertRect_fromView_ = objc.registerName(
  "convertRect:fromView:",
);
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ = objc.registerName(
  "setAutoresizesSubviews:",
);

sealed class UIViewAutoresizing {
  static const UIViewAutoresizingNone = 0;
  static const UIViewAutoresizingFlexibleLeftMargin = 1;
  static const UIViewAutoresizingFlexibleWidth = 2;
  static const UIViewAutoresizingFlexibleRightMargin = 4;
  static const UIViewAutoresizingFlexibleTopMargin = 8;
  static const UIViewAutoresizingFlexibleHeight = 16;
  static const UIViewAutoresizingFlexibleBottomMargin = 32;
}

late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_sq30wq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAutoresizingMask_ = objc.registerName(
  "setAutoresizingMask:",
);
final _objc_msgSend_qjq6uk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_sizeThatFits_ = objc.registerName("sizeThatFits:");
final _objc_msgSend_1owrp3b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
      )
    >();
final _objc_msgSend_1owrp3bStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
      )
    >();
late final _sel_sizeToFit = objc.registerName("sizeToFit");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// UIViewGeometry
extension UIViewGeometry on UIView {
  /// anchorPoint
  objc.CGPoint get anchorPoint {
    objc.checkOsVersionInternal('UIView.anchorPoint', iOS: (false, (16, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            $ptr,
            object$.ref.pointer,
            _sel_anchorPoint,
          )
        : $ptr.ref = _objc_msgSend_1uwdhlk(
            object$.ref.pointer,
            _sel_anchorPoint,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// autoresizesSubviews
  bool get autoresizesSubviews {
    objc.checkOsVersionInternal(
      'UIView.autoresizesSubviews',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_autoresizesSubviews);
  }

  /// autoresizingMask
  int get autoresizingMask {
    objc.checkOsVersionInternal(
      'UIView.autoresizingMask',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_sq30wq(object$.ref.pointer, _sel_autoresizingMask);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_bounds)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// center
  objc.CGPoint get center {
    objc.checkOsVersionInternal('UIView.center', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_center)
        : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_center);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// contentScaleFactor
  double get contentScaleFactor {
    objc.checkOsVersionInternal(
      'UIView.contentScaleFactor',
      iOS: (false, (4, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_contentScaleFactor,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_contentScaleFactor);
  }

  /// convertPoint:fromView:
  objc.CGPoint convertPoint(objc.CGPoint point, {UIView? fromView}) {
    objc.checkOsVersionInternal(
      'UIView.convertPoint:fromView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPoint:toView:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {UIView? toView}) {
    objc.checkOsVersionInternal(
      'UIView.convertPoint:toView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRect:fromView:
  objc.CGRect convertRect(objc.CGRect rect, {UIView? fromView}) {
    objc.checkOsVersionInternal(
      'UIView.convertRect:fromView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRect:toView:
  objc.CGRect convertRect$1(objc.CGRect rect, {UIView? toView}) {
    objc.checkOsVersionInternal(
      'UIView.convertRect:toView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// hitTest:withEvent:
  UIView? hitTest(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIView.hitTest:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_u7nfz8(
      object$.ref.pointer,
      _sel_hitTest_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// isExclusiveTouch
  bool get isExclusiveTouch {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isExclusiveTouch);
  }

  /// isMultipleTouchEnabled
  bool get isMultipleTouchEnabled {
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isMultipleTouchEnabled,
    );
  }

  /// pointInside:withEvent:
  bool pointInside(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIView.pointInside:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_yvwe5y(
      object$.ref.pointer,
      _sel_pointInside_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAnchorPoint:
  set anchorPoint(objc.CGPoint value) {
    objc.checkOsVersionInternal(
      'UIView.setAnchorPoint:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setAnchorPoint_, value);
  }

  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setAutoresizesSubviews:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutoresizesSubviews_,
      value,
    );
  }

  /// setAutoresizingMask:
  set autoresizingMask(int value) {
    objc.checkOsVersionInternal(
      'UIView.setAutoresizingMask:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_qjq6uk(object$.ref.pointer, _sel_setAutoresizingMask_, value);
  }

  /// setBounds:
  set bounds(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setBounds:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setBounds_, value);
  }

  /// setCenter:
  set center(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIView.setCenter:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setCenter_, value);
  }

  /// setContentScaleFactor:
  set contentScaleFactor(double value) {
    objc.checkOsVersionInternal(
      'UIView.setContentScaleFactor:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_hwm8nu(
      object$.ref.pointer,
      _sel_setContentScaleFactor_,
      value,
    );
  }

  /// setExclusiveTouch:
  set isExclusiveTouch(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setExclusiveTouch_, value);
  }

  /// setFrame:
  set frame(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setFrame:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setFrame_, value);
  }

  /// setMultipleTouchEnabled:
  set isMultipleTouchEnabled(bool value) {
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setMultipleTouchEnabled_,
      value,
    );
  }

  /// setTransform3D:
  set transform3D(CATransform3D value) {
    objc.checkOsVersionInternal(
      'UIView.setTransform3D:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s50tpz(object$.ref.pointer, _sel_setTransform3D_, value);
  }

  /// setTransform:
  set transform(CGAffineTransform value) {
    objc.checkOsVersionInternal(
      'UIView.setTransform:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_qgt66z(object$.ref.pointer, _sel_setTransform_, value);
  }

  /// sizeThatFits:
  objc.CGSize sizeThatFits(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'UIView.sizeThatFits:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_sizeThatFits_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_sizeThatFits_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// sizeToFit
  void sizeToFit() {
    objc.checkOsVersionInternal('UIView.sizeToFit', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_sizeToFit);
  }

  /// transform
  CGAffineTransform get transform {
    objc.checkOsVersionInternal('UIView.transform', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret($ptr, object$.ref.pointer, _sel_transform)
        : $ptr.ref = _objc_msgSend_5qswvj(object$.ref.pointer, _sel_transform);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CGAffineTransform>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CGAffineTransform>($finalizable);
  }

  /// transform3D
  CATransform3D get transform3D {
    objc.checkOsVersionInternal('UIView.transform3D', iOS: (false, (13, 0, 0)));
    final $ptr = pkg_ffi.calloc<CATransform3D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qlg3jStret($ptr, object$.ref.pointer, _sel_transform3D)
        : $ptr.ref = _objc_msgSend_5qlg3j(
            object$.ref.pointer,
            _sel_transform3D,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CATransform3D>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CATransform3D>($finalizable);
  }
}

late final _sel_superview = objc.registerName("superview");
late final _sel_subviews = objc.registerName("subviews");

/// WARNING: UIWindow is a stub. To generate bindings for this class, include
/// UIWindow in your config's objc-interfaces list.
///
/// UIWindow
extension type UIWindow._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIView {
  /// Constructs a [UIWindow] that points to the same underlying object as [other].
  UIWindow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIWindow', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIWindow] that wraps the given raw object pointer.
  UIWindow.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIWindow', iOS: (false, (2, 0, 0)));
  }
}

late final _sel_window = objc.registerName("window");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_insertSubview_atIndex_ = objc.registerName(
  "insertSubview:atIndex:",
);
final _objc_msgSend_1nvl641 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_exchangeSubviewAtIndex_withSubviewAtIndex_ = objc.registerName(
  "exchangeSubviewAtIndex:withSubviewAtIndex:",
);
final _objc_msgSend_1w5k0al = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
      )
    >();
late final _sel_addSubview_ = objc.registerName("addSubview:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_insertSubview_belowSubview_ = objc.registerName(
  "insertSubview:belowSubview:",
);
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_insertSubview_aboveSubview_ = objc.registerName(
  "insertSubview:aboveSubview:",
);
late final _sel_bringSubviewToFront_ = objc.registerName(
  "bringSubviewToFront:",
);
late final _sel_sendSubviewToBack_ = objc.registerName("sendSubviewToBack:");
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_willMoveToSuperview_ = objc.registerName(
  "willMoveToSuperview:",
);
late final _sel_didMoveToSuperview = objc.registerName("didMoveToSuperview");
late final _sel_willMoveToWindow_ = objc.registerName("willMoveToWindow:");
late final _sel_didMoveToWindow = objc.registerName("didMoveToWindow");
late final _sel_isDescendantOfView_ = objc.registerName("isDescendantOfView:");
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setNeedsUpdateProperties = objc.registerName(
  "setNeedsUpdateProperties",
);
late final _sel_updateProperties = objc.registerName("updateProperties");
late final _sel_updatePropertiesIfNeeded = objc.registerName(
  "updatePropertiesIfNeeded",
);
late final _sel_setNeedsLayout = objc.registerName("setNeedsLayout");
late final _sel_layoutIfNeeded = objc.registerName("layoutIfNeeded");
late final _sel_layoutSubviews = objc.registerName("layoutSubviews");
late final _sel_layoutMargins = objc.registerName("layoutMargins");
final _objc_msgSend_ct4cu5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        UIEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      UIEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_ct4cu5Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<UIEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<UIEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setLayoutMargins_ = objc.registerName("setLayoutMargins:");
final _objc_msgSend_1g8fos5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          UIEdgeInsets,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        UIEdgeInsets,
      )
    >();
late final _sel_directionalLayoutMargins = objc.registerName(
  "directionalLayoutMargins",
);
final _objc_msgSend_12yjd2m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSDirectionalEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      NSDirectionalEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_12yjd2mStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSDirectionalEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSDirectionalEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDirectionalLayoutMargins_ = objc.registerName(
  "setDirectionalLayoutMargins:",
);
final _objc_msgSend_s0isf8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          NSDirectionalEdgeInsets,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        NSDirectionalEdgeInsets,
      )
    >();
late final _sel_preservesSuperviewLayoutMargins = objc.registerName(
  "preservesSuperviewLayoutMargins",
);
late final _sel_setPreservesSuperviewLayoutMargins_ = objc.registerName(
  "setPreservesSuperviewLayoutMargins:",
);
late final _sel_insetsLayoutMarginsFromSafeArea = objc.registerName(
  "insetsLayoutMarginsFromSafeArea",
);
late final _sel_setInsetsLayoutMarginsFromSafeArea_ = objc.registerName(
  "setInsetsLayoutMarginsFromSafeArea:",
);
late final _sel_layoutMarginsDidChange = objc.registerName(
  "layoutMarginsDidChange",
);
late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
late final _sel_safeAreaInsetsDidChange = objc.registerName(
  "safeAreaInsetsDidChange",
);

/// WARNING: UILayoutGuide is a stub. To generate bindings for this class, include
/// UILayoutGuide in your config's objc-interfaces list.
///
/// UILayoutGuide
extension type UILayoutGuide._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCoding {
  /// Constructs a [UILayoutGuide] that points to the same underlying object as [other].
  UILayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UILayoutGuide] that wraps the given raw object pointer.
  UILayoutGuide.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }
}

late final _sel_layoutMarginsGuide = objc.registerName("layoutMarginsGuide");
late final _sel_readableContentGuide = objc.registerName(
  "readableContentGuide",
);
late final _sel_safeAreaLayoutGuide = objc.registerName("safeAreaLayoutGuide");

/// WARNING: UIKeyboardLayoutGuide is a stub. To generate bindings for this class, include
/// UIKeyboardLayoutGuide in your config's objc-interfaces list.
///
/// UIKeyboardLayoutGuide
extension type UIKeyboardLayoutGuide._(objc.ObjCObject object$)
    implements objc.ObjCObject, UITrackingLayoutGuide {
  /// Constructs a [UIKeyboardLayoutGuide] that points to the same underlying object as [other].
  UIKeyboardLayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIKeyboardLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }

  /// Constructs a [UIKeyboardLayoutGuide] that wraps the given raw object pointer.
  UIKeyboardLayoutGuide.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIKeyboardLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }
}

late final _sel_keyboardLayoutGuide = objc.registerName("keyboardLayoutGuide");

/// UIViewHierarchy
extension UIViewHierarchy on UIView {
  /// addSubview:
  void addSubview(UIView view) {
    objc.checkOsVersionInternal('UIView.addSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addSubview_,
      view.ref.pointer,
    );
  }

  /// bringSubviewToFront:
  void bringSubviewToFront(UIView view) {
    objc.checkOsVersionInternal(
      'UIView.bringSubviewToFront:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_bringSubviewToFront_,
      view.ref.pointer,
    );
  }

  /// didAddSubview:
  void didAddSubview(UIView subview) {
    objc.checkOsVersionInternal(
      'UIView.didAddSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_didAddSubview_,
      subview.ref.pointer,
    );
  }

  /// didMoveToSuperview
  void didMoveToSuperview() {
    objc.checkOsVersionInternal(
      'UIView.didMoveToSuperview',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_didMoveToSuperview);
  }

  /// didMoveToWindow
  void didMoveToWindow() {
    objc.checkOsVersionInternal(
      'UIView.didMoveToWindow',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_didMoveToWindow);
  }

  /// directionalLayoutMargins
  NSDirectionalEdgeInsets get directionalLayoutMargins {
    objc.checkOsVersionInternal(
      'UIView.directionalLayoutMargins',
      iOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_12yjd2mStret(
            $ptr,
            object$.ref.pointer,
            _sel_directionalLayoutMargins,
          )
        : $ptr.ref = _objc_msgSend_12yjd2m(
            object$.ref.pointer,
            _sel_directionalLayoutMargins,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>($finalizable);
  }

  /// exchangeSubviewAtIndex:withSubviewAtIndex:
  void exchangeSubviewAtIndex(int index1, {required int withSubviewAtIndex}) {
    objc.checkOsVersionInternal(
      'UIView.exchangeSubviewAtIndex:withSubviewAtIndex:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1w5k0al(
      object$.ref.pointer,
      _sel_exchangeSubviewAtIndex_withSubviewAtIndex_,
      index1,
      withSubviewAtIndex,
    );
  }

  /// insertSubview:aboveSubview:
  void insertSubview(UIView view, {required UIView aboveSubview}) {
    objc.checkOsVersionInternal(
      'UIView.insertSubview:aboveSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_insertSubview_aboveSubview_,
      view.ref.pointer,
      aboveSubview.ref.pointer,
    );
  }

  /// insertSubview:atIndex:
  void insertSubview$1(UIView view, {required int atIndex}) {
    objc.checkOsVersionInternal(
      'UIView.insertSubview:atIndex:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1nvl641(
      object$.ref.pointer,
      _sel_insertSubview_atIndex_,
      view.ref.pointer,
      atIndex,
    );
  }

  /// insertSubview:belowSubview:
  void insertSubview$2(UIView view, {required UIView belowSubview}) {
    objc.checkOsVersionInternal(
      'UIView.insertSubview:belowSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_insertSubview_belowSubview_,
      view.ref.pointer,
      belowSubview.ref.pointer,
    );
  }

  /// insetsLayoutMarginsFromSafeArea
  bool get insetsLayoutMarginsFromSafeArea {
    objc.checkOsVersionInternal(
      'UIView.insetsLayoutMarginsFromSafeArea',
      iOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_insetsLayoutMarginsFromSafeArea,
    );
  }

  /// isDescendantOfView:
  bool isDescendantOfView(UIView view) {
    objc.checkOsVersionInternal(
      'UIView.isDescendantOfView:',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isDescendantOfView_,
      view.ref.pointer,
    );
  }

  /// keyboardLayoutGuide
  UIKeyboardLayoutGuide get keyboardLayoutGuide {
    objc.checkOsVersionInternal(
      'UIView.keyboardLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_keyboardLayoutGuide,
    );
    return UIKeyboardLayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// layoutIfNeeded
  void layoutIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.layoutIfNeeded',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutIfNeeded);
  }

  /// layoutMargins
  UIEdgeInsets get layoutMargins {
    objc.checkOsVersionInternal(
      'UIView.layoutMargins',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_layoutMargins,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_layoutMargins,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// layoutMarginsDidChange
  void layoutMarginsDidChange() {
    objc.checkOsVersionInternal(
      'UIView.layoutMarginsDidChange',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutMarginsDidChange);
  }

  /// layoutMarginsGuide
  UILayoutGuide get layoutMarginsGuide {
    objc.checkOsVersionInternal(
      'UIView.layoutMarginsGuide',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_layoutMarginsGuide,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// layoutSubviews
  void layoutSubviews() {
    objc.checkOsVersionInternal(
      'UIView.layoutSubviews',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutSubviews);
  }

  /// preservesSuperviewLayoutMargins
  bool get preservesSuperviewLayoutMargins {
    objc.checkOsVersionInternal(
      'UIView.preservesSuperviewLayoutMargins',
      iOS: (false, (8, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_preservesSuperviewLayoutMargins,
    );
  }

  /// readableContentGuide
  UILayoutGuide get readableContentGuide {
    objc.checkOsVersionInternal(
      'UIView.readableContentGuide',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_readableContentGuide,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// removeFromSuperview
  void removeFromSuperview() {
    objc.checkOsVersionInternal(
      'UIView.removeFromSuperview',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_removeFromSuperview);
  }

  /// safeAreaInsets
  UIEdgeInsets get safeAreaInsets {
    objc.checkOsVersionInternal(
      'UIView.safeAreaInsets',
      iOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_safeAreaInsets,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_safeAreaInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// safeAreaInsetsDidChange
  void safeAreaInsetsDidChange() {
    objc.checkOsVersionInternal(
      'UIView.safeAreaInsetsDidChange',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_safeAreaInsetsDidChange);
  }

  /// safeAreaLayoutGuide
  UILayoutGuide get safeAreaLayoutGuide {
    objc.checkOsVersionInternal(
      'UIView.safeAreaLayoutGuide',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_safeAreaLayoutGuide,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// sendSubviewToBack:
  void sendSubviewToBack(UIView view) {
    objc.checkOsVersionInternal(
      'UIView.sendSubviewToBack:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_sendSubviewToBack_,
      view.ref.pointer,
    );
  }

  /// setDirectionalLayoutMargins:
  set directionalLayoutMargins(NSDirectionalEdgeInsets value) {
    objc.checkOsVersionInternal(
      'UIView.setDirectionalLayoutMargins:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_s0isf8(
      object$.ref.pointer,
      _sel_setDirectionalLayoutMargins_,
      value,
    );
  }

  /// setInsetsLayoutMarginsFromSafeArea:
  set insetsLayoutMarginsFromSafeArea(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setInsetsLayoutMarginsFromSafeArea:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setInsetsLayoutMarginsFromSafeArea_,
      value,
    );
  }

  /// setLayoutMargins:
  set layoutMargins(UIEdgeInsets value) {
    objc.checkOsVersionInternal(
      'UIView.setLayoutMargins:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1g8fos5(object$.ref.pointer, _sel_setLayoutMargins_, value);
  }

  /// setNeedsLayout
  void setNeedsLayout() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsLayout',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsLayout);
  }

  /// setNeedsUpdateProperties
  void setNeedsUpdateProperties() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsUpdateProperties',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateProperties);
  }

  /// setPreservesSuperviewLayoutMargins:
  set preservesSuperviewLayoutMargins(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setPreservesSuperviewLayoutMargins:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPreservesSuperviewLayoutMargins_,
      value,
    );
  }

  /// subviews
  objc.NSArray get subviews {
    objc.checkOsVersionInternal('UIView.subviews', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_subviews);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// superview
  UIView? get superview {
    objc.checkOsVersionInternal('UIView.superview', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_superview);
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// updateProperties
  void updateProperties() {
    objc.checkOsVersionInternal(
      'UIView.updateProperties',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateProperties);
  }

  /// updatePropertiesIfNeeded
  void updatePropertiesIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.updatePropertiesIfNeeded',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updatePropertiesIfNeeded);
  }

  /// viewWithTag:
  UIView? viewWithTag(int tag) {
    objc.checkOsVersionInternal('UIView.viewWithTag:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_qugqlf(
      object$.ref.pointer,
      _sel_viewWithTag_,
      tag,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// willMoveToSuperview:
  void willMoveToSuperview(UIView? newSuperview) {
    objc.checkOsVersionInternal(
      'UIView.willMoveToSuperview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_willMoveToSuperview_,
      newSuperview?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// willMoveToWindow:
  void willMoveToWindow(UIWindow? newWindow) {
    objc.checkOsVersionInternal(
      'UIView.willMoveToWindow:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_willMoveToWindow_,
      newWindow?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// willRemoveSubview:
  void willRemoveSubview(UIView subview) {
    objc.checkOsVersionInternal(
      'UIView.willRemoveSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_willRemoveSubview_,
      subview.ref.pointer,
    );
  }

  /// window
  UIWindow? get window {
    objc.checkOsVersionInternal('UIView.window', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_window);
    return $ret.address == 0
        ? null
        : UIWindow.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_setNeedsDisplay = objc.registerName("setNeedsDisplay");
late final _sel_setNeedsDisplayInRect_ = objc.registerName(
  "setNeedsDisplayInRect:",
);
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
late final _sel_alpha = objc.registerName("alpha");
late final _sel_setAlpha_ = objc.registerName("setAlpha:");
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_setOpaque_ = objc.registerName("setOpaque:");
late final _sel_clearsContextBeforeDrawing = objc.registerName(
  "clearsContextBeforeDrawing",
);
late final _sel_setClearsContextBeforeDrawing_ = objc.registerName(
  "setClearsContextBeforeDrawing:",
);
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");

enum UIViewContentMode {
  UIViewContentModeScaleToFill(0),
  UIViewContentModeScaleAspectFit(1),
  UIViewContentModeScaleAspectFill(2),
  UIViewContentModeRedraw(3),
  UIViewContentModeCenter(4),
  UIViewContentModeTop(5),
  UIViewContentModeBottom(6),
  UIViewContentModeLeft(7),
  UIViewContentModeRight(8),
  UIViewContentModeTopLeft(9),
  UIViewContentModeTopRight(10),
  UIViewContentModeBottomLeft(11),
  UIViewContentModeBottomRight(12);

  final int value;
  const UIViewContentMode(this.value);

  static UIViewContentMode fromValue(int value) => switch (value) {
    0 => UIViewContentModeScaleToFill,
    1 => UIViewContentModeScaleAspectFit,
    2 => UIViewContentModeScaleAspectFill,
    3 => UIViewContentModeRedraw,
    4 => UIViewContentModeCenter,
    5 => UIViewContentModeTop,
    6 => UIViewContentModeBottom,
    7 => UIViewContentModeLeft,
    8 => UIViewContentModeRight,
    9 => UIViewContentModeTopLeft,
    10 => UIViewContentModeTopRight,
    11 => UIViewContentModeBottomLeft,
    12 => UIViewContentModeBottomRight,
    _ => throw ArgumentError('Unknown value for UIViewContentMode: $value'),
  };
}

late final _sel_contentMode = objc.registerName("contentMode");
final _objc_msgSend_12r2l30 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setContentMode_ = objc.registerName("setContentMode:");
final _objc_msgSend_26z7iq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_contentStretch = objc.registerName("contentStretch");
late final _sel_setContentStretch_ = objc.registerName("setContentStretch:");
late final _sel_maskView = objc.registerName("maskView");
late final _sel_setMaskView_ = objc.registerName("setMaskView:");
late final _sel_tintColor = objc.registerName("tintColor");
late final _sel_setTintColor_ = objc.registerName("setTintColor:");

enum UIViewTintAdjustmentMode {
  UIViewTintAdjustmentModeAutomatic(0),
  UIViewTintAdjustmentModeNormal(1),
  UIViewTintAdjustmentModeDimmed(2);

  final int value;
  const UIViewTintAdjustmentMode(this.value);

  static UIViewTintAdjustmentMode fromValue(int value) => switch (value) {
    0 => UIViewTintAdjustmentModeAutomatic,
    1 => UIViewTintAdjustmentModeNormal,
    2 => UIViewTintAdjustmentModeDimmed,
    _ => throw ArgumentError(
      'Unknown value for UIViewTintAdjustmentMode: $value',
    ),
  };
}

late final _sel_tintAdjustmentMode = objc.registerName("tintAdjustmentMode");
final _objc_msgSend_1tlsbkb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTintAdjustmentMode_ = objc.registerName(
  "setTintAdjustmentMode:",
);
final _objc_msgSend_15t6owj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_tintColorDidChange = objc.registerName("tintColorDidChange");

/// UIViewRendering
extension UIViewRendering on UIView {
  /// alpha
  double get alpha {
    objc.checkOsVersionInternal('UIView.alpha', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_alpha)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_alpha);
  }

  /// backgroundColor
  UIColor? get backgroundColor {
    objc.checkOsVersionInternal(
      'UIView.backgroundColor',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backgroundColor,
    );
    return $ret.address == 0
        ? null
        : UIColor.fromPointer($ret, retain: true, release: true);
  }

  /// clearsContextBeforeDrawing
  bool get clearsContextBeforeDrawing {
    objc.checkOsVersionInternal(
      'UIView.clearsContextBeforeDrawing',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_clearsContextBeforeDrawing,
    );
  }

  /// clipsToBounds
  bool get clipsToBounds {
    objc.checkOsVersionInternal(
      'UIView.clipsToBounds',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_clipsToBounds);
  }

  /// contentMode
  UIViewContentMode get contentMode {
    objc.checkOsVersionInternal('UIView.contentMode', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_12r2l30(object$.ref.pointer, _sel_contentMode);
    return UIViewContentMode.fromValue($ret);
  }

  /// contentStretch
  objc.CGRect get contentStretch {
    objc.checkOsVersionInternal(
      'UIView.contentStretch',
      iOS: (false, (3, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_contentStretch,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_contentStretch,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// drawRect:
  void drawRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.drawRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_drawRect_, rect);
  }

  /// isHidden
  bool get isHidden {
    objc.checkOsVersionInternal('UIView.isHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHidden);
  }

  /// isOpaque
  bool get isOpaque {
    objc.checkOsVersionInternal('UIView.isOpaque', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isOpaque);
  }

  /// maskView
  UIView? get maskView {
    objc.checkOsVersionInternal('UIView.maskView', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_maskView);
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// setAlpha:
  set alpha(double value) {
    objc.checkOsVersionInternal('UIView.setAlpha:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setAlpha_, value);
  }

  /// setBackgroundColor:
  set backgroundColor(UIColor? value) {
    objc.checkOsVersionInternal(
      'UIView.setBackgroundColor:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBackgroundColor_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setClearsContextBeforeDrawing:
  set clearsContextBeforeDrawing(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setClearsContextBeforeDrawing:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setClearsContextBeforeDrawing_,
      value,
    );
  }

  /// setClipsToBounds:
  set clipsToBounds(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setClipsToBounds:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setClipsToBounds_, value);
  }

  /// setContentMode:
  set contentMode(UIViewContentMode value) {
    objc.checkOsVersionInternal(
      'UIView.setContentMode:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_26z7iq(
      object$.ref.pointer,
      _sel_setContentMode_,
      value.value,
    );
  }

  /// setContentStretch:
  set contentStretch(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'UIView.setContentStretch:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setContentStretch_, value);
  }

  /// setHidden:
  set isHidden(bool value) {
    objc.checkOsVersionInternal('UIView.setHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHidden_, value);
  }

  /// setMaskView:
  set maskView(UIView? value) {
    objc.checkOsVersionInternal('UIView.setMaskView:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMaskView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setNeedsDisplay
  void setNeedsDisplay() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsDisplay',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsDisplay);
  }

  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'UIView.setNeedsDisplayInRect:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_setNeedsDisplayInRect_,
      rect,
    );
  }

  /// setOpaque:
  set isOpaque(bool value) {
    objc.checkOsVersionInternal('UIView.setOpaque:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setOpaque_, value);
  }

  /// setTintAdjustmentMode:
  set tintAdjustmentMode(UIViewTintAdjustmentMode value) {
    objc.checkOsVersionInternal(
      'UIView.setTintAdjustmentMode:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_15t6owj(
      object$.ref.pointer,
      _sel_setTintAdjustmentMode_,
      value.value,
    );
  }

  /// setTintColor:
  set tintColor(UIColor value) {
    objc.checkOsVersionInternal(
      'UIView.setTintColor:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTintColor_,
      value.ref.pointer,
    );
  }

  /// tintAdjustmentMode
  UIViewTintAdjustmentMode get tintAdjustmentMode {
    objc.checkOsVersionInternal(
      'UIView.tintAdjustmentMode',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_1tlsbkb(
      object$.ref.pointer,
      _sel_tintAdjustmentMode,
    );
    return UIViewTintAdjustmentMode.fromValue($ret);
  }

  /// tintColor
  UIColor get tintColor {
    objc.checkOsVersionInternal('UIView.tintColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tintColor);
    return UIColor.fromPointer($ret, retain: true, release: true);
  }

  /// tintColorDidChange
  void tintColorDidChange() {
    objc.checkOsVersionInternal(
      'UIView.tintColorDidChange',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_tintColorDidChange);
  }
}

late final _sel_setAnimationsEnabled_ = objc.registerName(
  "setAnimationsEnabled:",
);
late final _sel_areAnimationsEnabled = objc.registerName(
  "areAnimationsEnabled",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1pl9qdv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

late final _sel_performWithoutAnimation_ = objc.registerName(
  "performWithoutAnimation:",
);
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_inheritedAnimationDuration = objc.registerName(
  "inheritedAnimationDuration",
);

/// UIViewAnimation
extension UIViewAnimation on UIView {
  /// areAnimationsEnabled
  static bool getAreAnimationsEnabled() {
    objc.checkOsVersionInternal(
      'UIView.areAnimationsEnabled',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(_class_UIView, _sel_areAnimationsEnabled);
  }

  /// inheritedAnimationDuration
  static double getInheritedAnimationDuration() {
    objc.checkOsVersionInternal(
      'UIView.inheritedAnimationDuration',
      iOS: (false, (9, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            _class_UIView,
            _sel_inheritedAnimationDuration,
          )
        : _objc_msgSend_1ukqyt8(_class_UIView, _sel_inheritedAnimationDuration);
  }

  /// performWithoutAnimation:
  static void performWithoutAnimation(
    objc.ObjCBlock<ffi.Void Function()> actionsWithoutAnimation,
  ) {
    objc.checkOsVersionInternal(
      'UIView.performWithoutAnimation:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_f167m6(
      _class_UIView,
      _sel_performWithoutAnimation_,
      actionsWithoutAnimation.ref.pointer,
    );
  }

  /// setAnimationsEnabled:
  static void setAnimationsEnabled(bool enabled) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationsEnabled:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationsEnabled_, enabled);
  }
}

sealed class UIViewAnimationOptions {
  static const UIViewAnimationOptionLayoutSubviews = 1;
  static const UIViewAnimationOptionAllowUserInteraction = 2;
  static const UIViewAnimationOptionBeginFromCurrentState = 4;
  static const UIViewAnimationOptionRepeat = 8;
  static const UIViewAnimationOptionAutoreverse = 16;
  static const UIViewAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewAnimationOptionOverrideInheritedCurve = 64;
  static const UIViewAnimationOptionAllowAnimatedContent = 128;
  static const UIViewAnimationOptionShowHideTransitionViews = 256;
  static const UIViewAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewAnimationOptionCurveEaseInOut = 0;
  static const UIViewAnimationOptionCurveEaseIn = 65536;
  static const UIViewAnimationOptionCurveEaseOut = 131072;
  static const UIViewAnimationOptionCurveLinear = 196608;
  static const UIViewAnimationOptionTransitionNone = 0;
  static const UIViewAnimationOptionTransitionFlipFromLeft = 1048576;
  static const UIViewAnimationOptionTransitionFlipFromRight = 2097152;
  static const UIViewAnimationOptionTransitionCurlUp = 3145728;
  static const UIViewAnimationOptionTransitionCurlDown = 4194304;
  static const UIViewAnimationOptionTransitionCrossDissolve = 5242880;
  static const UIViewAnimationOptionTransitionFlipFromTop = 6291456;
  static const UIViewAnimationOptionTransitionFlipFromBottom = 7340032;
  static const UIViewAnimationOptionPreferredFramesPerSecondDefault = 0;
  static const UIViewAnimationOptionPreferredFramesPerSecond60 = 50331648;
  static const UIViewAnimationOptionPreferredFramesPerSecond30 = 117440512;
  static const UIViewAnimationOptionFlushUpdates = 268435456;
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newClosureBlock(
      _closureCallable,
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1s56lr9(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    bool arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(bool))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
      .asFunction<void Function(bool)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) => (objc.getBlockClosure(block) as void Function(bool))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Bool arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(
        ref.pointer,
        arg0,
      );
}

late final _sel_animateWithDuration_delay_options_animations_completion_ = objc
    .registerName("animateWithDuration:delay:options:animations:completion:");
final _objc_msgSend_1pforg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_completion_ = objc.registerName(
  "animateWithDuration:animations:completion:",
);
final _objc_msgSend_1isavsq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_ = objc.registerName(
  "animateWithDuration:animations:",
);
final _objc_msgSend_16dy26p = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_ =
    objc.registerName(
      "animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:",
    );
final _objc_msgSend_r4l13g = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_ =
    objc.registerName(
      "animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:",
    );
late final _sel_transitionWithView_duration_options_animations_completion_ =
    objc.registerName(
      "transitionWithView:duration:options:animations:completion:",
    );
final _objc_msgSend_q6v4dl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_transitionFromView_toView_duration_options_completion_ = objc
    .registerName("transitionFromView:toView:duration:options:completion:");
final _objc_msgSend_1eh0loo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

enum UISystemAnimation {
  UISystemAnimationDelete(0);

  final int value;
  const UISystemAnimation(this.value);

  static UISystemAnimation fromValue(int value) => switch (value) {
    0 => UISystemAnimationDelete,
    _ => throw ArgumentError('Unknown value for UISystemAnimation: $value'),
  };
}

late final _sel_performSystemAnimation_onViews_options_animations_completion_ =
    objc.registerName(
      "performSystemAnimation:onViews:options:animations:completion:",
    );
final _objc_msgSend_fqrtz5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_ = objc
    .registerName("modifyAnimationsWithRepeatCount:autoreverses:animations:");
final _objc_msgSend_nxk2e9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewAnimationWithBlocks
extension UIViewAnimationWithBlocks on UIView {
  /// animateWithDuration:animations:
  static void animateWithDuration(
    double duration, {
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:animations:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_16dy26p(
      _class_UIView,
      _sel_animateWithDuration_animations_,
      duration,
      animations.ref.pointer,
    );
  }

  /// animateWithDuration:animations:completion:
  static void animateWithDuration$1(
    double duration, {
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1isavsq(
      _class_UIView,
      _sel_animateWithDuration_animations_completion_,
      duration,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:delay:options:animations:completion:
  static void animateWithDuration$2(
    double duration, {
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1pforg(
      _class_UIView,
      _sel_animateWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:
  static void animateWithDuration$3(
    double duration, {
    required double delay,
    required double usingSpringWithDamping,
    required double initialSpringVelocity,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_r4l13g(
      _class_UIView,
      _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_,
      duration,
      delay,
      usingSpringWithDamping,
      initialSpringVelocity,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:
  static void animateWithSpringDuration(
    double duration, {
    required double bounce,
    required double initialSpringVelocity,
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:',
      iOS: (false, (17, 0, 0)),
    );
    _objc_msgSend_r4l13g(
      _class_UIView,
      _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_,
      duration,
      bounce,
      initialSpringVelocity,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// modifyAnimationsWithRepeatCount:autoreverses:animations:
  static void modifyAnimationsWithRepeatCount(
    double count, {
    required bool autoreverses,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.modifyAnimationsWithRepeatCount:autoreverses:animations:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_nxk2e9(
      _class_UIView,
      _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_,
      count,
      autoreverses,
      animations.ref.pointer,
    );
  }

  /// performSystemAnimation:onViews:options:animations:completion:
  static void performSystemAnimation(
    UISystemAnimation animation, {
    required objc.NSArray onViews,
    required int options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.performSystemAnimation:onViews:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_fqrtz5(
      _class_UIView,
      _sel_performSystemAnimation_onViews_options_animations_completion_,
      animation.value,
      onViews.ref.pointer,
      options,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionFromView:toView:duration:options:completion:
  static void transitionFromView(
    UIView fromView, {
    required UIView toView,
    required double duration,
    required int options,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionFromView:toView:duration:options:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1eh0loo(
      _class_UIView,
      _sel_transitionFromView_toView_duration_options_completion_,
      fromView.ref.pointer,
      toView.ref.pointer,
      duration,
      options,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionWithView:duration:options:animations:completion:
  static void transitionWithView(
    UIView view, {
    required double duration,
    required int options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionWithView:duration:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_q6v4dl(
      _class_UIView,
      _sel_transitionWithView_duration_options_animations_completion_,
      view.ref.pointer,
      duration,
      options,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }
}

sealed class UIViewKeyframeAnimationOptions {
  static const UIViewKeyframeAnimationOptionLayoutSubviews = 1;
  static const UIViewKeyframeAnimationOptionAllowUserInteraction = 2;
  static const UIViewKeyframeAnimationOptionBeginFromCurrentState = 4;
  static const UIViewKeyframeAnimationOptionRepeat = 8;
  static const UIViewKeyframeAnimationOptionAutoreverse = 16;
  static const UIViewKeyframeAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewKeyframeAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewKeyframeAnimationOptionCalculationModeLinear = 0;
  static const UIViewKeyframeAnimationOptionCalculationModeDiscrete = 1024;
  static const UIViewKeyframeAnimationOptionCalculationModePaced = 2048;
  static const UIViewKeyframeAnimationOptionCalculationModeCubic = 3072;
  static const UIViewKeyframeAnimationOptionCalculationModeCubicPaced = 4096;
}

late final _sel_animateKeyframesWithDuration_delay_options_animations_completion_ =
    objc.registerName(
      "animateKeyframesWithDuration:delay:options:animations:completion:",
    );
final _objc_msgSend_ciuhtc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_ =
    objc.registerName(
      "addKeyframeWithRelativeStartTime:relativeDuration:animations:",
    );
final _objc_msgSend_6jt11a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewKeyframeAnimations
extension UIViewKeyframeAnimations on UIView {
  /// addKeyframeWithRelativeStartTime:relativeDuration:animations:
  static void addKeyframeWithRelativeStartTime(
    double frameStartTime, {
    required double relativeDuration,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.addKeyframeWithRelativeStartTime:relativeDuration:animations:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_6jt11a(
      _class_UIView,
      _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_,
      frameStartTime,
      relativeDuration,
      animations.ref.pointer,
    );
  }

  /// animateKeyframesWithDuration:delay:options:animations:completion:
  static void animateKeyframesWithDuration(
    double duration, {
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateKeyframesWithDuration:delay:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_ciuhtc(
      _class_UIView,
      _sel_animateKeyframesWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_gestureRecognizers = objc.registerName("gestureRecognizers");
late final _sel_setGestureRecognizers_ = objc.registerName(
  "setGestureRecognizers:",
);

/// WARNING: UIGestureRecognizer is a stub. To generate bindings for this class, include
/// UIGestureRecognizer in your config's objc-interfaces list.
///
/// UIGestureRecognizer
extension type UIGestureRecognizer._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIGestureRecognizer] that points to the same underlying object as [other].
  UIGestureRecognizer.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIGestureRecognizer] that wraps the given raw object pointer.
  UIGestureRecognizer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIGestureRecognizer', iOS: (false, (3, 2, 0)));
  }
}

late final _sel_addGestureRecognizer_ = objc.registerName(
  "addGestureRecognizer:",
);
late final _sel_removeGestureRecognizer_ = objc.registerName(
  "removeGestureRecognizer:",
);
late final _sel_gestureRecognizerShouldBegin_ = objc.registerName(
  "gestureRecognizerShouldBegin:",
);

/// UIViewGestureRecognizers
extension UIViewGestureRecognizers on UIView {
  /// addGestureRecognizer:
  void addGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal(
      'UIView.addGestureRecognizer:',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addGestureRecognizer_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal(
      'UIView.gestureRecognizerShouldBegin:',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_gestureRecognizerShouldBegin_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizers
  objc.NSArray? get gestureRecognizers {
    objc.checkOsVersionInternal(
      'UIView.gestureRecognizers',
      iOS: (false, (3, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_gestureRecognizers,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeGestureRecognizer:
  void removeGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal(
      'UIView.removeGestureRecognizer:',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeGestureRecognizer_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// setGestureRecognizers:
  set gestureRecognizers(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'UIView.setGestureRecognizers:',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setGestureRecognizers_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// WARNING: UIMotionEffect is a stub. To generate bindings for this class, include
/// UIMotionEffect in your config's objc-interfaces list.
///
/// UIMotionEffect
extension type UIMotionEffect._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [UIMotionEffect] that points to the same underlying object as [other].
  UIMotionEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMotionEffect', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIMotionEffect] that wraps the given raw object pointer.
  UIMotionEffect.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMotionEffect', iOS: (false, (7, 0, 0)));
  }
}

late final _sel_addMotionEffect_ = objc.registerName("addMotionEffect:");
late final _sel_removeMotionEffect_ = objc.registerName("removeMotionEffect:");
late final _sel_motionEffects = objc.registerName("motionEffects");
late final _sel_setMotionEffects_ = objc.registerName("setMotionEffects:");

/// UIViewMotionEffects
extension UIViewMotionEffects on UIView {
  /// addMotionEffect:
  void addMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal(
      'UIView.addMotionEffect:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addMotionEffect_,
      effect.ref.pointer,
    );
  }

  /// motionEffects
  objc.NSArray get motionEffects {
    objc.checkOsVersionInternal(
      'UIView.motionEffects',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_motionEffects);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeMotionEffect:
  void removeMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal(
      'UIView.removeMotionEffect:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeMotionEffect_,
      effect.ref.pointer,
    );
  }

  /// setMotionEffects:
  set motionEffects(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'UIView.setMotionEffects:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMotionEffects_,
      value.ref.pointer,
    );
  }
}

late final _sel_constraints = objc.registerName("constraints");

/// WARNING: NSLayoutConstraint is a stub. To generate bindings for this class, include
/// NSLayoutConstraint in your config's objc-interfaces list.
///
/// NSLayoutConstraint
extension type NSLayoutConstraint._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSLayoutConstraint] that points to the same underlying object as [other].
  NSLayoutConstraint.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
  }

  /// Constructs a [NSLayoutConstraint] that wraps the given raw object pointer.
  NSLayoutConstraint.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
  }
}

late final _sel_addConstraint_ = objc.registerName("addConstraint:");
late final _sel_addConstraints_ = objc.registerName("addConstraints:");
late final _sel_removeConstraint_ = objc.registerName("removeConstraint:");
late final _sel_removeConstraints_ = objc.registerName("removeConstraints:");

/// UIConstraintBasedLayoutInstallingConstraints
extension UIConstraintBasedLayoutInstallingConstraints on UIView {
  /// addConstraint:
  void addConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal(
      'UIView.addConstraint:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addConstraint_,
      constraint.ref.pointer,
    );
  }

  /// addConstraints:
  void addConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'UIView.addConstraints:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addConstraints_,
      constraints.ref.pointer,
    );
  }

  /// constraints
  objc.NSArray get constraints {
    objc.checkOsVersionInternal('UIView.constraints', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_constraints);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeConstraint:
  void removeConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal(
      'UIView.removeConstraint:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeConstraint_,
      constraint.ref.pointer,
    );
  }

  /// removeConstraints:
  void removeConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'UIView.removeConstraints:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeConstraints_,
      constraints.ref.pointer,
    );
  }
}

late final _sel_updateConstraintsIfNeeded = objc.registerName(
  "updateConstraintsIfNeeded",
);
late final _sel_updateConstraints = objc.registerName("updateConstraints");
late final _sel_needsUpdateConstraints = objc.registerName(
  "needsUpdateConstraints",
);
late final _sel_setNeedsUpdateConstraints = objc.registerName(
  "setNeedsUpdateConstraints",
);

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods on UIView {
  /// needsUpdateConstraints
  bool needsUpdateConstraints() {
    objc.checkOsVersionInternal(
      'UIView.needsUpdateConstraints',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_needsUpdateConstraints,
    );
  }

  /// setNeedsUpdateConstraints
  void setNeedsUpdateConstraints() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsUpdateConstraints',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateConstraints);
  }

  /// updateConstraints
  void updateConstraints() {
    objc.checkOsVersionInternal(
      'UIView.updateConstraints',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateConstraints);
  }

  /// updateConstraintsIfNeeded
  void updateConstraintsIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.updateConstraintsIfNeeded',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateConstraintsIfNeeded);
  }
}

late final _sel_translatesAutoresizingMaskIntoConstraints = objc.registerName(
  "translatesAutoresizingMaskIntoConstraints",
);
late final _sel_setTranslatesAutoresizingMaskIntoConstraints_ = objc
    .registerName("setTranslatesAutoresizingMaskIntoConstraints:");
late final _sel_requiresConstraintBasedLayout = objc.registerName(
  "requiresConstraintBasedLayout",
);

/// UIConstraintBasedCompatibility
extension UIConstraintBasedCompatibility on UIView {
  /// setTranslatesAutoresizingMaskIntoConstraints:
  set translatesAutoresizingMaskIntoConstraints(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setTranslatesAutoresizingMaskIntoConstraints:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setTranslatesAutoresizingMaskIntoConstraints_,
      value,
    );
  }

  /// translatesAutoresizingMaskIntoConstraints
  bool get translatesAutoresizingMaskIntoConstraints {
    objc.checkOsVersionInternal(
      'UIView.translatesAutoresizingMaskIntoConstraints',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_translatesAutoresizingMaskIntoConstraints,
    );
  }

  /// requiresConstraintBasedLayout
  static bool getRequiresConstraintBasedLayout() {
    objc.checkOsVersionInternal(
      'UIView.requiresConstraintBasedLayout',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(
      _class_UIView,
      _sel_requiresConstraintBasedLayout,
    );
  }
}

late final _sel_alignmentRectForFrame_ = objc.registerName(
  "alignmentRectForFrame:",
);
final _objc_msgSend_1gn1s3d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_frameForAlignmentRect_ = objc.registerName(
  "frameForAlignmentRect:",
);
late final _sel_alignmentRectInsets = objc.registerName("alignmentRectInsets");
late final _sel_viewForBaselineLayout = objc.registerName(
  "viewForBaselineLayout",
);
late final _sel_viewForFirstBaselineLayout = objc.registerName(
  "viewForFirstBaselineLayout",
);
late final _sel_viewForLastBaselineLayout = objc.registerName(
  "viewForLastBaselineLayout",
);
late final _sel_intrinsicContentSize = objc.registerName(
  "intrinsicContentSize",
);
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_invalidateIntrinsicContentSize = objc.registerName(
  "invalidateIntrinsicContentSize",
);

enum UILayoutConstraintAxis {
  UILayoutConstraintAxisHorizontal(0),
  UILayoutConstraintAxisVertical(1);

  final int value;
  const UILayoutConstraintAxis(this.value);

  static UILayoutConstraintAxis fromValue(int value) => switch (value) {
    0 => UILayoutConstraintAxisHorizontal,
    1 => UILayoutConstraintAxisVertical,
    _ => throw ArgumentError(
      'Unknown value for UILayoutConstraintAxis: $value',
    ),
  };
}

late final _sel_contentHuggingPriorityForAxis_ = objc.registerName(
  "contentHuggingPriorityForAxis:",
);
final _objc_msgSend_qigf85 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_qigf85Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setContentHuggingPriority_forAxis_ = objc.registerName(
  "setContentHuggingPriority:forAxis:",
);
final _objc_msgSend_wd7esz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        int,
      )
    >();
late final _sel_contentCompressionResistancePriorityForAxis_ = objc
    .registerName("contentCompressionResistancePriorityForAxis:");
late final _sel_setContentCompressionResistancePriority_forAxis_ = objc
    .registerName("setContentCompressionResistancePriority:forAxis:");

/// UIConstraintBasedLayoutLayering
extension UIConstraintBasedLayoutLayering on UIView {
  /// alignmentRectForFrame:
  objc.CGRect alignmentRectForFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal(
      'UIView.alignmentRectForFrame:',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_alignmentRectForFrame_,
            frame,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_alignmentRectForFrame_,
            frame,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// alignmentRectInsets
  UIEdgeInsets get alignmentRectInsets {
    objc.checkOsVersionInternal(
      'UIView.alignmentRectInsets',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_alignmentRectInsets,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_alignmentRectInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// contentCompressionResistancePriorityForAxis:
  double contentCompressionResistancePriorityForAxis(
    UILayoutConstraintAxis axis,
  ) {
    objc.checkOsVersionInternal(
      'UIView.contentCompressionResistancePriorityForAxis:',
      iOS: (false, (6, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(
            object$.ref.pointer,
            _sel_contentCompressionResistancePriorityForAxis_,
            axis.value,
          )
        : _objc_msgSend_qigf85(
            object$.ref.pointer,
            _sel_contentCompressionResistancePriorityForAxis_,
            axis.value,
          );
  }

  /// contentHuggingPriorityForAxis:
  double contentHuggingPriorityForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal(
      'UIView.contentHuggingPriorityForAxis:',
      iOS: (false, (6, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(
            object$.ref.pointer,
            _sel_contentHuggingPriorityForAxis_,
            axis.value,
          )
        : _objc_msgSend_qigf85(
            object$.ref.pointer,
            _sel_contentHuggingPriorityForAxis_,
            axis.value,
          );
  }

  /// frameForAlignmentRect:
  objc.CGRect frameForAlignmentRect(objc.CGRect alignmentRect) {
    objc.checkOsVersionInternal(
      'UIView.frameForAlignmentRect:',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_frameForAlignmentRect_,
            alignmentRect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_frameForAlignmentRect_,
            alignmentRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// intrinsicContentSize
  objc.CGSize get intrinsicContentSize {
    objc.checkOsVersionInternal(
      'UIView.intrinsicContentSize',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(
            $ptr,
            object$.ref.pointer,
            _sel_intrinsicContentSize,
          )
        : $ptr.ref = _objc_msgSend_1vdfken(
            object$.ref.pointer,
            _sel_intrinsicContentSize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// invalidateIntrinsicContentSize
  void invalidateIntrinsicContentSize() {
    objc.checkOsVersionInternal(
      'UIView.invalidateIntrinsicContentSize',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_invalidateIntrinsicContentSize,
    );
  }

  /// setContentCompressionResistancePriority:forAxis:
  void setContentCompressionResistancePriority(
    double priority, {
    required UILayoutConstraintAxis forAxis,
  }) {
    objc.checkOsVersionInternal(
      'UIView.setContentCompressionResistancePriority:forAxis:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_wd7esz(
      object$.ref.pointer,
      _sel_setContentCompressionResistancePriority_forAxis_,
      priority,
      forAxis.value,
    );
  }

  /// setContentHuggingPriority:forAxis:
  void setContentHuggingPriority(
    double priority, {
    required UILayoutConstraintAxis forAxis,
  }) {
    objc.checkOsVersionInternal(
      'UIView.setContentHuggingPriority:forAxis:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_wd7esz(
      object$.ref.pointer,
      _sel_setContentHuggingPriority_forAxis_,
      priority,
      forAxis.value,
    );
  }

  /// viewForBaselineLayout
  UIView viewForBaselineLayout() {
    objc.checkOsVersionInternal(
      'UIView.viewForBaselineLayout',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewForBaselineLayout,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// viewForFirstBaselineLayout
  UIView get viewForFirstBaselineLayout {
    objc.checkOsVersionInternal(
      'UIView.viewForFirstBaselineLayout',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewForFirstBaselineLayout,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// viewForLastBaselineLayout
  UIView get viewForLastBaselineLayout {
    objc.checkOsVersionInternal(
      'UIView.viewForLastBaselineLayout',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewForLastBaselineLayout,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_systemLayoutSizeFittingSize_ = objc.registerName(
  "systemLayoutSizeFittingSize:",
);
late final _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_ =
    objc.registerName(
      "systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:",
    );
final _objc_msgSend_3fx2qn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        double,
        double,
      )
    >();
final _objc_msgSend_3fx2qnStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        double,
        double,
      )
    >();

/// UIConstraintBasedLayoutFittingSize
extension UIConstraintBasedLayoutFittingSize on UIView {
  /// systemLayoutSizeFittingSize:
  objc.CGSize systemLayoutSizeFittingSize(objc.CGSize targetSize) {
    objc.checkOsVersionInternal(
      'UIView.systemLayoutSizeFittingSize:',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_,
            targetSize,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_,
            targetSize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:
  objc.CGSize systemLayoutSizeFittingSize$1(
    objc.CGSize targetSize, {
    required double withHorizontalFittingPriority,
    required double verticalFittingPriority,
  }) {
    objc.checkOsVersionInternal(
      'UIView.systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3fx2qnStret(
            $ptr,
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          )
        : $ptr.ref = _objc_msgSend_3fx2qn(
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }
}

late final _sel_layoutGuides = objc.registerName("layoutGuides");
late final _sel_addLayoutGuide_ = objc.registerName("addLayoutGuide:");
late final _sel_removeLayoutGuide_ = objc.registerName("removeLayoutGuide:");

/// UILayoutGuideSupport
extension UILayoutGuideSupport on UIView {
  /// addLayoutGuide:
  void addLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal(
      'UIView.addLayoutGuide:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addLayoutGuide_,
      layoutGuide.ref.pointer,
    );
  }

  /// layoutGuides
  objc.NSArray get layoutGuides {
    objc.checkOsVersionInternal('UIView.layoutGuides', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layoutGuides);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeLayoutGuide:
  void removeLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal(
      'UIView.removeLayoutGuide:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeLayoutGuide_,
      layoutGuide.ref.pointer,
    );
  }
}

/// WARNING: NSLayoutXAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutXAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutXAxisAnchor
extension type NSLayoutXAxisAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutXAxisAnchor] that points to the same underlying object as [other].
  NSLayoutXAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutXAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutXAxisAnchor] that wraps the given raw object pointer.
  NSLayoutXAxisAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutXAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_leadingAnchor = objc.registerName("leadingAnchor");
late final _sel_trailingAnchor = objc.registerName("trailingAnchor");
late final _sel_leftAnchor = objc.registerName("leftAnchor");
late final _sel_rightAnchor = objc.registerName("rightAnchor");

/// WARNING: NSLayoutYAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutYAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutYAxisAnchor
extension type NSLayoutYAxisAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutYAxisAnchor] that points to the same underlying object as [other].
  NSLayoutYAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutYAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutYAxisAnchor] that wraps the given raw object pointer.
  NSLayoutYAxisAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutYAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_topAnchor = objc.registerName("topAnchor");
late final _sel_bottomAnchor = objc.registerName("bottomAnchor");

/// WARNING: NSLayoutDimension is a stub. To generate bindings for this class, include
/// NSLayoutDimension in your config's objc-interfaces list.
///
/// NSLayoutDimension
extension type NSLayoutDimension._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutDimension] that points to the same underlying object as [other].
  NSLayoutDimension.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutDimension',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutDimension] that wraps the given raw object pointer.
  NSLayoutDimension.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutDimension',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_widthAnchor = objc.registerName("widthAnchor");
late final _sel_heightAnchor = objc.registerName("heightAnchor");
late final _sel_centerXAnchor = objc.registerName("centerXAnchor");
late final _sel_centerYAnchor = objc.registerName("centerYAnchor");
late final _sel_firstBaselineAnchor = objc.registerName("firstBaselineAnchor");
late final _sel_lastBaselineAnchor = objc.registerName("lastBaselineAnchor");

/// UIViewLayoutConstraintCreation
extension UIViewLayoutConstraintCreation on UIView {
  /// bottomAnchor
  NSLayoutYAxisAnchor get bottomAnchor {
    objc.checkOsVersionInternal('UIView.bottomAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_bottomAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// centerXAnchor
  NSLayoutXAxisAnchor get centerXAnchor {
    objc.checkOsVersionInternal(
      'UIView.centerXAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerXAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// centerYAnchor
  NSLayoutYAxisAnchor get centerYAnchor {
    objc.checkOsVersionInternal(
      'UIView.centerYAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerYAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// firstBaselineAnchor
  NSLayoutYAxisAnchor get firstBaselineAnchor {
    objc.checkOsVersionInternal(
      'UIView.firstBaselineAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_firstBaselineAnchor,
    );
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// heightAnchor
  NSLayoutDimension get heightAnchor {
    objc.checkOsVersionInternal('UIView.heightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heightAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }

  /// lastBaselineAnchor
  NSLayoutYAxisAnchor get lastBaselineAnchor {
    objc.checkOsVersionInternal(
      'UIView.lastBaselineAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_lastBaselineAnchor,
    );
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// leadingAnchor
  NSLayoutXAxisAnchor get leadingAnchor {
    objc.checkOsVersionInternal(
      'UIView.leadingAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leadingAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// leftAnchor
  NSLayoutXAxisAnchor get leftAnchor {
    objc.checkOsVersionInternal('UIView.leftAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leftAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// rightAnchor
  NSLayoutXAxisAnchor get rightAnchor {
    objc.checkOsVersionInternal('UIView.rightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rightAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// topAnchor
  NSLayoutYAxisAnchor get topAnchor {
    objc.checkOsVersionInternal('UIView.topAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_topAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// trailingAnchor
  NSLayoutXAxisAnchor get trailingAnchor {
    objc.checkOsVersionInternal(
      'UIView.trailingAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_trailingAnchor,
    );
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// widthAnchor
  NSLayoutDimension get widthAnchor {
    objc.checkOsVersionInternal('UIView.widthAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_widthAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_constraintsAffectingLayoutForAxis_ = objc.registerName(
  "constraintsAffectingLayoutForAxis:",
);
final _objc_msgSend_5swr7b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_hasAmbiguousLayout = objc.registerName("hasAmbiguousLayout");
late final _sel_exerciseAmbiguityInLayout = objc.registerName(
  "exerciseAmbiguityInLayout",
);

/// UIConstraintBasedLayoutDebugging
extension UIConstraintBasedLayoutDebugging on UIView {
  /// constraintsAffectingLayoutForAxis:
  objc.NSArray constraintsAffectingLayoutForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal(
      'UIView.constraintsAffectingLayoutForAxis:',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_5swr7b(
      object$.ref.pointer,
      _sel_constraintsAffectingLayoutForAxis_,
      axis.value,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// exerciseAmbiguityInLayout
  void exerciseAmbiguityInLayout() {
    objc.checkOsVersionInternal(
      'UIView.exerciseAmbiguityInLayout',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_exerciseAmbiguityInLayout);
  }

  /// hasAmbiguousLayout
  bool get hasAmbiguousLayout {
    objc.checkOsVersionInternal(
      'UIView.hasAmbiguousLayout',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hasAmbiguousLayout);
  }
}

late final _sel_restorationIdentifier = objc.registerName(
  "restorationIdentifier",
);
late final _sel_setRestorationIdentifier_ = objc.registerName(
  "setRestorationIdentifier:",
);
late final _sel_encodeRestorableStateWithCoder_ = objc.registerName(
  "encodeRestorableStateWithCoder:",
);
late final _sel_decodeRestorableStateWithCoder_ = objc.registerName(
  "decodeRestorableStateWithCoder:",
);

/// UIStateRestoration
extension UIStateRestoration on UIView {
  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal(
      'UIView.decodeRestorableStateWithCoder:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_decodeRestorableStateWithCoder_,
      coder.ref.pointer,
    );
  }

  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal(
      'UIView.encodeRestorableStateWithCoder:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeRestorableStateWithCoder_,
      coder.ref.pointer,
    );
  }

  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
    objc.checkOsVersionInternal(
      'UIView.restorationIdentifier',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_restorationIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setRestorationIdentifier:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setRestorationIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_snapshotViewAfterScreenUpdates_ = objc.registerName(
  "snapshotViewAfterScreenUpdates:",
);
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_ =
    objc.registerName(
      "resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:",
    );
final _objc_msgSend_qvletk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Bool,
          UIEdgeInsets,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        bool,
        UIEdgeInsets,
      )
    >();
late final _sel_drawViewHierarchyInRect_afterScreenUpdates_ = objc.registerName(
  "drawViewHierarchyInRect:afterScreenUpdates:",
);
final _objc_msgSend_19ljaqg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        bool,
      )
    >();

/// UISnapshotting
extension UISnapshotting on UIView {
  /// drawViewHierarchyInRect:afterScreenUpdates:
  bool drawViewHierarchyInRect(
    objc.CGRect rect, {
    required bool afterScreenUpdates,
  }) {
    objc.checkOsVersionInternal(
      'UIView.drawViewHierarchyInRect:afterScreenUpdates:',
      iOS: (false, (7, 0, 0)),
    );
    return _objc_msgSend_19ljaqg(
      object$.ref.pointer,
      _sel_drawViewHierarchyInRect_afterScreenUpdates_,
      rect,
      afterScreenUpdates,
    );
  }

  /// resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:
  UIView? resizableSnapshotViewFromRect(
    objc.CGRect rect, {
    required bool afterScreenUpdates,
    required UIEdgeInsets withCapInsets,
  }) {
    objc.checkOsVersionInternal(
      'UIView.resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_qvletk(
      object$.ref.pointer,
      _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_,
      rect,
      afterScreenUpdates,
      withCapInsets,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// snapshotViewAfterScreenUpdates:
  UIView? snapshotViewAfterScreenUpdates(bool afterUpdates) {
    objc.checkOsVersionInternal(
      'UIView.snapshotViewAfterScreenUpdates:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_1t6aok9(
      object$.ref.pointer,
      _sel_snapshotViewAfterScreenUpdates_,
      afterUpdates,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_beginAnimations_context_ = objc.registerName(
  "beginAnimations:context:",
);
final _objc_msgSend_1lzqwav = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_commitAnimations = objc.registerName("commitAnimations");
late final _sel_setAnimationDelegate_ = objc.registerName(
  "setAnimationDelegate:",
);
late final _sel_setAnimationWillStartSelector_ = objc.registerName(
  "setAnimationWillStartSelector:",
);
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAnimationDidStopSelector_ = objc.registerName(
  "setAnimationDidStopSelector:",
);
late final _sel_setAnimationDuration_ = objc.registerName(
  "setAnimationDuration:",
);
late final _sel_setAnimationDelay_ = objc.registerName("setAnimationDelay:");
late final _sel_setAnimationStartDate_ = objc.registerName(
  "setAnimationStartDate:",
);

enum UIViewAnimationCurve {
  UIViewAnimationCurveEaseInOut(0),
  UIViewAnimationCurveEaseIn(1),
  UIViewAnimationCurveEaseOut(2),
  UIViewAnimationCurveLinear(3);

  final int value;
  const UIViewAnimationCurve(this.value);

  static UIViewAnimationCurve fromValue(int value) => switch (value) {
    0 => UIViewAnimationCurveEaseInOut,
    1 => UIViewAnimationCurveEaseIn,
    2 => UIViewAnimationCurveEaseOut,
    3 => UIViewAnimationCurveLinear,
    _ => throw ArgumentError('Unknown value for UIViewAnimationCurve: $value'),
  };
}

late final _sel_setAnimationCurve_ = objc.registerName("setAnimationCurve:");
final _objc_msgSend_up32gn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setAnimationRepeatCount_ = objc.registerName(
  "setAnimationRepeatCount:",
);
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_setAnimationRepeatAutoreverses_ = objc.registerName(
  "setAnimationRepeatAutoreverses:",
);
late final _sel_setAnimationBeginsFromCurrentState_ = objc.registerName(
  "setAnimationBeginsFromCurrentState:",
);

enum UIViewAnimationTransition {
  UIViewAnimationTransitionNone(0),
  UIViewAnimationTransitionFlipFromLeft(1),
  UIViewAnimationTransitionFlipFromRight(2),
  UIViewAnimationTransitionCurlUp(3),
  UIViewAnimationTransitionCurlDown(4);

  final int value;
  const UIViewAnimationTransition(this.value);

  static UIViewAnimationTransition fromValue(int value) => switch (value) {
    0 => UIViewAnimationTransitionNone,
    1 => UIViewAnimationTransitionFlipFromLeft,
    2 => UIViewAnimationTransitionFlipFromRight,
    3 => UIViewAnimationTransitionCurlUp,
    4 => UIViewAnimationTransitionCurlDown,
    _ => throw ArgumentError(
      'Unknown value for UIViewAnimationTransition: $value',
    ),
  };
}

late final _sel_setAnimationTransition_forView_cache_ = objc.registerName(
  "setAnimationTransition:forView:cache:",
);
final _objc_msgSend_1ftk3d5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();

/// DeprecatedAnimations
extension DeprecatedAnimations on UIView {
  /// beginAnimations:context:
  static void beginAnimations(
    objc.NSString? animationID, {
    required ffi.Pointer<ffi.Void> context,
  }) {
    objc.checkOsVersionInternal(
      'UIView.beginAnimations:context:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1lzqwav(
      _class_UIView,
      _sel_beginAnimations_context_,
      animationID?.ref.pointer ?? ffi.nullptr,
      context,
    );
  }

  /// commitAnimations
  static void commitAnimations() {
    objc.checkOsVersionInternal(
      'UIView.commitAnimations',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(_class_UIView, _sel_commitAnimations);
  }

  /// setAnimationBeginsFromCurrentState:
  static void setAnimationBeginsFromCurrentState(bool fromCurrentState) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationBeginsFromCurrentState:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      _class_UIView,
      _sel_setAnimationBeginsFromCurrentState_,
      fromCurrentState,
    );
  }

  /// setAnimationCurve:
  static void setAnimationCurve(UIViewAnimationCurve curve) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationCurve:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_up32gn(_class_UIView, _sel_setAnimationCurve_, curve.value);
  }

  /// setAnimationDelay:
  static void setAnimationDelay(double delay) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDelay:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDelay_, delay);
  }

  /// setAnimationDelegate:
  static void setAnimationDelegate(objc.ObjCObject? delegate) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDelegate:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_UIView,
      _sel_setAnimationDelegate_,
      delegate?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAnimationDidStopSelector:
  static void setAnimationDidStopSelector(
    ffi.Pointer<objc.ObjCSelector> selector,
  ) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDidStopSelector:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1d9e4oe(
      _class_UIView,
      _sel_setAnimationDidStopSelector_,
      selector,
    );
  }

  /// setAnimationDuration:
  static void setAnimationDuration(double duration) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDuration:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDuration_, duration);
  }

  /// setAnimationRepeatAutoreverses:
  static void setAnimationRepeatAutoreverses(bool repeatAutoreverses) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationRepeatAutoreverses:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      _class_UIView,
      _sel_setAnimationRepeatAutoreverses_,
      repeatAutoreverses,
    );
  }

  /// setAnimationRepeatCount:
  static void setAnimationRepeatCount(double repeatCount) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationRepeatCount:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_v5hmet(
      _class_UIView,
      _sel_setAnimationRepeatCount_,
      repeatCount,
    );
  }

  /// setAnimationStartDate:
  static void setAnimationStartDate(objc.NSDate startDate) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationStartDate:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_UIView,
      _sel_setAnimationStartDate_,
      startDate.ref.pointer,
    );
  }

  /// setAnimationTransition:forView:cache:
  static void setAnimationTransition(
    UIViewAnimationTransition transition, {
    required UIView forView,
    required bool cache,
  }) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationTransition:forView:cache:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1ftk3d5(
      _class_UIView,
      _sel_setAnimationTransition_forView_cache_,
      transition.value,
      forView.ref.pointer,
      cache,
    );
  }

  /// setAnimationWillStartSelector:
  static void setAnimationWillStartSelector(
    ffi.Pointer<objc.ObjCSelector> selector,
  ) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationWillStartSelector:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1d9e4oe(
      _class_UIView,
      _sel_setAnimationWillStartSelector_,
      selector,
    );
  }
}

enum UIUserInterfaceStyle {
  UIUserInterfaceStyleUnspecified(0),
  UIUserInterfaceStyleLight(1),
  UIUserInterfaceStyleDark(2);

  final int value;
  const UIUserInterfaceStyle(this.value);

  static UIUserInterfaceStyle fromValue(int value) => switch (value) {
    0 => UIUserInterfaceStyleUnspecified,
    1 => UIUserInterfaceStyleLight,
    2 => UIUserInterfaceStyleDark,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceStyle: $value'),
  };
}

late final _sel_overrideUserInterfaceStyle = objc.registerName(
  "overrideUserInterfaceStyle",
);
final _objc_msgSend_2x5ago = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setOverrideUserInterfaceStyle_ = objc.registerName(
  "setOverrideUserInterfaceStyle:",
);
final _objc_msgSend_15dz1ky = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// UserInterfaceStyle
extension UserInterfaceStyle on UIView {
  /// overrideUserInterfaceStyle
  UIUserInterfaceStyle get overrideUserInterfaceStyle {
    objc.checkOsVersionInternal(
      'UIView.overrideUserInterfaceStyle',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_2x5ago(
      object$.ref.pointer,
      _sel_overrideUserInterfaceStyle,
    );
    return UIUserInterfaceStyle.fromValue($ret);
  }

  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(UIUserInterfaceStyle value) {
    objc.checkOsVersionInternal(
      'UIView.setOverrideUserInterfaceStyle:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_15dz1ky(
      object$.ref.pointer,
      _sel_setOverrideUserInterfaceStyle_,
      value.value,
    );
  }
}

late final _sel_minimumContentSizeCategory = objc.registerName(
  "minimumContentSizeCategory",
);
late final _sel_setMinimumContentSizeCategory_ = objc.registerName(
  "setMinimumContentSizeCategory:",
);
late final _sel_maximumContentSizeCategory = objc.registerName(
  "maximumContentSizeCategory",
);
late final _sel_setMaximumContentSizeCategory_ = objc.registerName(
  "setMaximumContentSizeCategory:",
);
late final _sel_appliedContentSizeCategoryLimitsDescription = objc.registerName(
  "appliedContentSizeCategoryLimitsDescription",
);

/// UIContentSizeCategoryLimit
extension UIContentSizeCategoryLimit on UIView {
  /// appliedContentSizeCategoryLimitsDescription
  objc.NSString get appliedContentSizeCategoryLimitsDescription {
    objc.checkOsVersionInternal(
      'UIView.appliedContentSizeCategoryLimitsDescription',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_appliedContentSizeCategoryLimitsDescription,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// maximumContentSizeCategory
  objc.NSString? get maximumContentSizeCategory {
    objc.checkOsVersionInternal(
      'UIView.maximumContentSizeCategory',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_maximumContentSizeCategory,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// minimumContentSizeCategory
  objc.NSString? get minimumContentSizeCategory {
    objc.checkOsVersionInternal(
      'UIView.minimumContentSizeCategory',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_minimumContentSizeCategory,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setMaximumContentSizeCategory:
  set maximumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setMaximumContentSizeCategory:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMaximumContentSizeCategory_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMinimumContentSizeCategory:
  set minimumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setMinimumContentSizeCategory:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMinimumContentSizeCategory_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// WARNING: UITraitChangeObservable is a stub. To generate bindings for this class, include
/// UITraitChangeObservable in your config's objc-protocols list.
///
/// UITraitChangeObservable
extension type UITraitChangeObservable._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [UITraitChangeObservable] that points to the same underlying object as [other].
  UITraitChangeObservable.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitChangeObservable] that wraps the given raw object pointer.
  UITraitChangeObservable.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

///
extension unnamed on UIView {}

/// WARNING: UIViewLayoutRegion is a stub. To generate bindings for this class, include
/// UIViewLayoutRegion in your config's objc-interfaces list.
///
/// UIViewLayoutRegion
extension type UIViewLayoutRegion._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIViewLayoutRegion] that points to the same underlying object as [other].
  UIViewLayoutRegion.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewLayoutRegion', iOS: (false, (26, 0, 0)));
  }

  /// Constructs a [UIViewLayoutRegion] that wraps the given raw object pointer.
  UIViewLayoutRegion.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewLayoutRegion', iOS: (false, (26, 0, 0)));
  }
}

late final _sel_layoutGuideForLayoutRegion_ = objc.registerName(
  "layoutGuideForLayoutRegion:",
);
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_edgeInsetsForLayoutRegion_ = objc.registerName(
  "edgeInsetsForLayoutRegion:",
);
final _objc_msgSend_16w06qx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        UIEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      UIEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_16w06qxStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<UIEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<UIEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_directionalEdgeInsetsForLayoutRegion_ = objc.registerName(
  "directionalEdgeInsetsForLayoutRegion:",
);
final _objc_msgSend_wk01t0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSDirectionalEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      NSDirectionalEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_wk01t0Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSDirectionalEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSDirectionalEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// LayoutRegions
extension LayoutRegions on UIView {
  /// directionalEdgeInsetsForLayoutRegion:
  NSDirectionalEdgeInsets directionalEdgeInsetsForLayoutRegion(
    UIViewLayoutRegion layoutRegion,
  ) {
    objc.checkOsVersionInternal(
      'UIView.directionalEdgeInsetsForLayoutRegion:',
      iOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_wk01t0Stret(
            $ptr,
            object$.ref.pointer,
            _sel_directionalEdgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_wk01t0(
            object$.ref.pointer,
            _sel_directionalEdgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>($finalizable);
  }

  /// edgeInsetsForLayoutRegion:
  UIEdgeInsets edgeInsetsForLayoutRegion(UIViewLayoutRegion layoutRegion) {
    objc.checkOsVersionInternal(
      'UIView.edgeInsetsForLayoutRegion:',
      iOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_16w06qxStret(
            $ptr,
            object$.ref.pointer,
            _sel_edgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_16w06qx(
            object$.ref.pointer,
            _sel_edgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// layoutGuideForLayoutRegion:
  UILayoutGuide layoutGuideForLayoutRegion(UIViewLayoutRegion layoutRegion) {
    objc.checkOsVersionInternal(
      'UIView.layoutGuideForLayoutRegion:',
      iOS: (false, (26, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_layoutGuideForLayoutRegion_,
      layoutRegion.ref.pointer,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UICornerConfiguration is a stub. To generate bindings for this class, include
/// UICornerConfiguration in your config's objc-interfaces list.
///
/// UICornerConfiguration
extension type UICornerConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UICornerConfiguration] that points to the same underlying object as [other].
  UICornerConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UICornerConfiguration',
      iOS: (false, (26, 0, 0)),
    );
  }

  /// Constructs a [UICornerConfiguration] that wraps the given raw object pointer.
  UICornerConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UICornerConfiguration',
      iOS: (false, (26, 0, 0)),
    );
  }
}

late final _sel_cornerConfiguration = objc.registerName("cornerConfiguration");
late final _sel_setCornerConfiguration_ = objc.registerName(
  "setCornerConfiguration:",
);
late final _sel_effectiveRadiusForCorner_ = objc.registerName(
  "effectiveRadiusForCorner:",
);
final _objc_msgSend_8ud30b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_8ud30bFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// CornerConfiguration
extension CornerConfiguration on UIView {
  /// cornerConfiguration
  UICornerConfiguration get cornerConfiguration {
    objc.checkOsVersionInternal(
      'UIView.cornerConfiguration',
      iOS: (false, (26, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_cornerConfiguration,
    );
    return UICornerConfiguration.fromPointer($ret, retain: true, release: true);
  }

  /// effectiveRadiusForCorner:
  double effectiveRadiusForCorner(int corner) {
    objc.checkOsVersionInternal(
      'UIView.effectiveRadiusForCorner:',
      iOS: (false, (26, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_8ud30bFpret(
            object$.ref.pointer,
            _sel_effectiveRadiusForCorner_,
            corner,
          )
        : _objc_msgSend_8ud30b(
            object$.ref.pointer,
            _sel_effectiveRadiusForCorner_,
            corner,
          );
  }

  /// setCornerConfiguration:
  set cornerConfiguration(UICornerConfiguration value) {
    objc.checkOsVersionInternal(
      'UIView.setCornerConfiguration:',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCornerConfiguration_,
      value.ref.pointer,
    );
  }
}

/// WARNING: UIInteraction is a stub. To generate bindings for this class, include
/// UIInteraction in your config's objc-protocols list.
///
/// UIInteraction
extension type UIInteraction._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIInteraction] that points to the same underlying object as [other].
  UIInteraction.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIInteraction] that wraps the given raw object pointer.
  UIInteraction.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_addInteraction_ = objc.registerName("addInteraction:");
late final _sel_removeInteraction_ = objc.registerName("removeInteraction:");
late final _sel_interactions = objc.registerName("interactions");
late final _sel_setInteractions_ = objc.registerName("setInteractions:");

/// Interactions
extension Interactions on UIView {
  /// addInteraction:
  void addInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal(
      'UIView.addInteraction:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addInteraction_,
      interaction.ref.pointer,
    );
  }

  /// interactions
  objc.NSArray get interactions {
    objc.checkOsVersionInternal(
      'UIView.interactions',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_interactions);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeInteraction:
  void removeInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal(
      'UIView.removeInteraction:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeInteraction_,
      interaction.ref.pointer,
    );
  }

  /// setInteractions:
  set interactions(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'UIView.setInteractions:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setInteractions_,
      value.ref.pointer,
    );
  }
}

late final _sel_accessibilityIgnoresInvertColors = objc.registerName(
  "accessibilityIgnoresInvertColors",
);
late final _sel_setAccessibilityIgnoresInvertColors_ = objc.registerName(
  "setAccessibilityIgnoresInvertColors:",
);

/// UIAccessibilityInvertColors
extension UIAccessibilityInvertColors on UIView {
  /// accessibilityIgnoresInvertColors
  bool get accessibilityIgnoresInvertColors {
    objc.checkOsVersionInternal(
      'UIView.accessibilityIgnoresInvertColors',
      iOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityIgnoresInvertColors,
    );
  }

  /// setAccessibilityIgnoresInvertColors:
  set accessibilityIgnoresInvertColors(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setAccessibilityIgnoresInvertColors:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityIgnoresInvertColors_,
      value,
    );
  }
}

late final _sel_endEditing_ = objc.registerName("endEditing:");
final _objc_msgSend_41h7k3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();

/// UITextField
extension UITextField on UIView {
  /// endEditing:
  bool endEditing(bool force) {
    objc.checkOsVersionInternal('UIView.endEditing:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_41h7k3(object$.ref.pointer, _sel_endEditing_, force);
  }
}

late final _sel_accessibilityIdentifier = objc.registerName(
  "accessibilityIdentifier",
);

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSString? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$1$CallExtension
    on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.NSString.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setAccessibilityIdentifier_ = objc.registerName(
  "setAccessibilityIdentifier:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.NSString.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSString$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

/// WARNING: UIAccessibilityIdentification is a stub. To generate bindings for this class, include
/// UIAccessibilityIdentification in your config's objc-protocols list.
///
/// UIAccessibilityIdentification
extension type UIAccessibilityIdentification._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAccessibilityIdentification] that points to the same underlying object as [other].
  UIAccessibilityIdentification.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAccessibilityIdentification] that wraps the given raw object pointer.
  UIAccessibilityIdentification.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIAccessibility
extension UIAccessibility on UIView {
  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
    objc.checkOsVersionInternal(
      'UIView.accessibilityIdentifier',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setAccessibilityIdentifier:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_showsLargeContentViewer = objc.registerName(
  "showsLargeContentViewer",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_setShowsLargeContentViewer_ = objc.registerName(
  "setShowsLargeContentViewer:",
);
late final _sel_largeContentTitle = objc.registerName("largeContentTitle");
late final _sel_setLargeContentTitle_ = objc.registerName(
  "setLargeContentTitle:",
);
late final _sel_largeContentImage = objc.registerName("largeContentImage");

/// Construction methods for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIImage_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIImage? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIImage_ffiVoid$CallExtension
    on objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> {
  UIImage? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIImage.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setLargeContentImage_ = objc.registerName(
  "setLargeContentImage:",
);
late final _sel_scalesLargeContentImage = objc.registerName(
  "scalesLargeContentImage",
);
late final _sel_setScalesLargeContentImage_ = objc.registerName(
  "setScalesLargeContentImage:",
);
late final _sel_largeContentImageInsets = objc.registerName(
  "largeContentImageInsets",
);

/// Construction methods for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIEdgeInsets_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    UIEdgeInsets Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static UIEdgeInsets _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            UIEdgeInsets Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static UIEdgeInsets _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as UIEdgeInsets Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            UIEdgeInsets Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIEdgeInsets_ffiVoid$CallExtension
    on objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> {
  UIEdgeInsets call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          UIEdgeInsets Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        UIEdgeInsets Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_setLargeContentImageInsets_ = objc.registerName(
  "setLargeContentImageInsets:",
);

/// WARNING: UILargeContentViewerItem is a stub. To generate bindings for this class, include
/// UILargeContentViewerItem in your config's objc-protocols list.
///
/// UILargeContentViewerItem
extension type UILargeContentViewerItem._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UILargeContentViewerItem] that points to the same underlying object as [other].
  UILargeContentViewerItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UILargeContentViewerItem] that wraps the given raw object pointer.
  UILargeContentViewerItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UILargeContentViewer
extension UILargeContentViewer on UIView {
  /// largeContentImage
  UIImage? get largeContentImage {
    objc.checkOsVersionInternal(
      'UIView.largeContentImage',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_largeContentImage,
    );
    return $ret.address == 0
        ? null
        : UIImage.fromPointer($ret, retain: true, release: true);
  }

  /// largeContentImageInsets
  UIEdgeInsets get largeContentImageInsets {
    objc.checkOsVersionInternal(
      'UIView.largeContentImageInsets',
      iOS: (false, (13, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_largeContentImageInsets,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_largeContentImageInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// largeContentTitle
  objc.NSString? get largeContentTitle {
    objc.checkOsVersionInternal(
      'UIView.largeContentTitle',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_largeContentTitle,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// scalesLargeContentImage
  bool get scalesLargeContentImage {
    objc.checkOsVersionInternal(
      'UIView.scalesLargeContentImage',
      iOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_scalesLargeContentImage,
    );
  }

  /// setLargeContentImage:
  set largeContentImage$1(UIImage? value) {
    objc.checkOsVersionInternal(
      'UIView.setLargeContentImage:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setLargeContentImage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setLargeContentImageInsets:
  set largeContentImageInsets$1(UIEdgeInsets value) {
    objc.checkOsVersionInternal(
      'UIView.setLargeContentImageInsets:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1g8fos5(
      object$.ref.pointer,
      _sel_setLargeContentImageInsets_,
      value,
    );
  }

  /// setLargeContentTitle:
  set largeContentTitle$1(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setLargeContentTitle:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setLargeContentTitle_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setScalesLargeContentImage:
  set scalesLargeContentImage$1(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setScalesLargeContentImage:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setScalesLargeContentImage_,
      value,
    );
  }

  /// setShowsLargeContentViewer:
  set showsLargeContentViewer(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setShowsLargeContentViewer:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setShowsLargeContentViewer_,
      value,
    );
  }

  /// showsLargeContentViewer
  bool get showsLargeContentViewer$1 {
    objc.checkOsVersionInternal(
      'UIView.showsLargeContentViewer',
      iOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_showsLargeContentViewer,
    );
  }
}

/// WARNING: UIHoverStyle$1 is a stub. To generate bindings for this class, include
/// UIHoverStyle in your config's objc-interfaces list.
///
/// UIHoverStyle
extension type UIHoverStyle$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UIHoverStyle$1] that points to the same underlying object as [other].
  UIHoverStyle$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIHoverStyle', iOS: (false, (17, 0, 0)));
  }

  /// Constructs a [UIHoverStyle$1] that wraps the given raw object pointer.
  UIHoverStyle$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIHoverStyle', iOS: (false, (17, 0, 0)));
  }
}

late final _sel_hoverStyle = objc.registerName("hoverStyle");
late final _sel_setHoverStyle_ = objc.registerName("setHoverStyle:");

/// UIHoverStyle
extension UIHoverStyle on UIView {
  /// hoverStyle
  UIHoverStyle$1? get hoverStyle {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hoverStyle);
    return $ret.address == 0
        ? null
        : UIHoverStyle$1.fromPointer($ret, retain: true, release: true);
  }

  /// setHoverStyle:
  set hoverStyle(UIHoverStyle$1? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setHoverStyle_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_frameInView_ = objc.registerName("frameInView:");
final _objc_msgSend_qrtfce = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_qrtfceStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_UIView {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, UIView.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGRect _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGRect _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGRect Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
extension ObjCBlock_CGRect_ffiVoid_UIView$CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, UIView arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: UIPopoverPresentationControllerSourceItem$1 is a stub. To generate bindings for this class, include
/// UIPopoverPresentationControllerSourceItem in your config's objc-protocols list.
///
/// UIPopoverPresentationControllerSourceItem
extension type UIPopoverPresentationControllerSourceItem$1._(
  objc.ObjCProtocol object$
)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIPopoverPresentationControllerSourceItem$1] that points to the same underlying object as [other].
  UIPopoverPresentationControllerSourceItem$1.as(objc.ObjCObject other)
    : object$ = other;

  /// Constructs a [UIPopoverPresentationControllerSourceItem$1] that wraps the given raw object pointer.
  UIPopoverPresentationControllerSourceItem$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIPopoverPresentationControllerSourceItem
extension UIPopoverPresentationControllerSourceItem on UIView {
  /// frameInView:
  objc.CGRect frameInView(UIView referenceView) {
    objc.checkOsVersionInternal(
      'UIView.frameInView:',
      iOS: (false, (17, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qrtfceStret(
            $ptr,
            object$.ref.pointer,
            _sel_frameInView_,
            referenceView.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_qrtfce(
            object$.ref.pointer,
            _sel_frameInView_,
            referenceView.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }
}

/// WARNING: UIViewPrintFormatter is a stub. To generate bindings for this class, include
/// UIViewPrintFormatter in your config's objc-interfaces list.
///
/// UIViewPrintFormatter
extension type UIViewPrintFormatter._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIPrintFormatter$1 {
  /// Constructs a [UIViewPrintFormatter] that points to the same underlying object as [other].
  UIViewPrintFormatter.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIViewPrintFormatter',
      iOS: (false, (4, 2, 0)),
    );
  }

  /// Constructs a [UIViewPrintFormatter] that wraps the given raw object pointer.
  UIViewPrintFormatter.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIViewPrintFormatter',
      iOS: (false, (4, 2, 0)),
    );
  }
}

late final _sel_viewPrintFormatter = objc.registerName("viewPrintFormatter");
late final _sel_drawRect_forViewPrintFormatter_ = objc.registerName(
  "drawRect:forViewPrintFormatter:",
);
final _objc_msgSend_f227js = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// UIPrintFormatter
extension UIPrintFormatter on UIView {
  /// drawRect:forViewPrintFormatter:
  void drawRect(
    objc.CGRect rect, {
    required UIViewPrintFormatter forViewPrintFormatter,
  }) {
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_drawRect_forViewPrintFormatter_,
      rect,
      forViewPrintFormatter.ref.pointer,
    );
  }

  /// viewPrintFormatter
  UIViewPrintFormatter viewPrintFormatter() {
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewPrintFormatter,
    );
    return UIViewPrintFormatter.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIAppearance is a stub. To generate bindings for this class, include
/// UIAppearance in your config's objc-protocols list.
///
/// UIAppearance
extension type UIAppearance._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAppearance] that points to the same underlying object as [other].
  UIAppearance.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAppearance] that wraps the given raw object pointer.
  UIAppearance.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIAppearanceContainer is a stub. To generate bindings for this class, include
/// UIAppearanceContainer in your config's objc-protocols list.
///
/// UIAppearanceContainer
extension type UIAppearanceContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAppearanceContainer] that points to the same underlying object as [other].
  UIAppearanceContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAppearanceContainer] that wraps the given raw object pointer.
  UIAppearanceContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIDynamicItem is a stub. To generate bindings for this class, include
/// UIDynamicItem in your config's objc-protocols list.
///
/// UIDynamicItem
extension type UIDynamicItem._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIDynamicItem] that points to the same underlying object as [other].
  UIDynamicItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIDynamicItem] that wraps the given raw object pointer.
  UIDynamicItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UITraitEnvironment is a stub. To generate bindings for this class, include
/// UITraitEnvironment in your config's objc-protocols list.
///
/// UITraitEnvironment
extension type UITraitEnvironment._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UITraitEnvironment] that points to the same underlying object as [other].
  UITraitEnvironment.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitEnvironment] that wraps the given raw object pointer.
  UITraitEnvironment.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UICoordinateSpace is a stub. To generate bindings for this class, include
/// UICoordinateSpace in your config's objc-protocols list.
///
/// UICoordinateSpace
extension type UICoordinateSpace._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UICoordinateSpace] that points to the same underlying object as [other].
  UICoordinateSpace.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UICoordinateSpace] that wraps the given raw object pointer.
  UICoordinateSpace.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIFocusItem is a stub. To generate bindings for this class, include
/// UIFocusItem in your config's objc-protocols list.
///
/// UIFocusItem
extension type UIFocusItem._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, UIFocusEnvironment {
  /// Constructs a [UIFocusItem] that points to the same underlying object as [other].
  UIFocusItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusItem] that wraps the given raw object pointer.
  UIFocusItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIFocusItemContainer is a stub. To generate bindings for this class, include
/// UIFocusItemContainer in your config's objc-protocols list.
///
/// UIFocusItemContainer
extension type UIFocusItemContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIFocusItemContainer] that points to the same underlying object as [other].
  UIFocusItemContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusItemContainer] that wraps the given raw object pointer.
  UIFocusItemContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIView
extension type UIView._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        UIResponder,
        objc.NSCoding,
        UIAppearance,
        UIAppearanceContainer,
        UIDynamicItem,
        UITraitEnvironment,
        UICoordinateSpace,
        UIFocusItem,
        UIFocusItemContainer,
        CALayerDelegate {
  /// Constructs a [UIView] that points to the same underlying object as [other].
  UIView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIView] that wraps the given raw object pointer.
  UIView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIView,
  );
}

extension UIView$Methods on UIView {}

late final _sel_inputView = objc.registerName("inputView");
late final _sel_inputAccessoryView = objc.registerName("inputAccessoryView");

/// WARNING: UITextInputAssistantItem is a stub. To generate bindings for this class, include
/// UITextInputAssistantItem in your config's objc-interfaces list.
///
/// UITextInputAssistantItem
extension type UITextInputAssistantItem._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UITextInputAssistantItem] that points to the same underlying object as [other].
  UITextInputAssistantItem.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UITextInputAssistantItem',
      iOS: (false, (9, 0, 0)),
    );
  }

  /// Constructs a [UITextInputAssistantItem] that wraps the given raw object pointer.
  UITextInputAssistantItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UITextInputAssistantItem',
      iOS: (false, (9, 0, 0)),
    );
  }
}

late final _sel_inputAssistantItem = objc.registerName("inputAssistantItem");

/// WARNING: UIInputViewController is a stub. To generate bindings for this class, include
/// UIInputViewController in your config's objc-interfaces list.
///
/// UIInputViewController
extension type UIInputViewController._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIViewController, UITextInputDelegate {
  /// Constructs a [UIInputViewController] that points to the same underlying object as [other].
  UIInputViewController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIInputViewController',
      iOS: (false, (8, 0, 0)),
    );
  }

  /// Constructs a [UIInputViewController] that wraps the given raw object pointer.
  UIInputViewController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIInputViewController',
      iOS: (false, (8, 0, 0)),
    );
  }
}

late final _sel_inputViewController = objc.registerName("inputViewController");
late final _sel_inputAccessoryViewController = objc.registerName(
  "inputAccessoryViewController",
);

/// WARNING: UITextInputMode is a stub. To generate bindings for this class, include
/// UITextInputMode in your config's objc-interfaces list.
///
/// UITextInputMode
extension type UITextInputMode._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [UITextInputMode] that points to the same underlying object as [other].
  UITextInputMode.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UITextInputMode] that wraps the given raw object pointer.
  UITextInputMode.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }
}

late final _sel_textInputMode = objc.registerName("textInputMode");
late final _sel_textInputContextIdentifier = objc.registerName(
  "textInputContextIdentifier",
);
late final _sel_clearTextInputContextIdentifier_ = objc.registerName(
  "clearTextInputContextIdentifier:",
);
late final _sel_reloadInputViews = objc.registerName("reloadInputViews");

/// UIResponderInputViewAdditions
extension UIResponderInputViewAdditions on UIResponder {
  /// inputAccessoryView
  UIView? get inputAccessoryView {
    objc.checkOsVersionInternal(
      'UIResponder.inputAccessoryView',
      iOS: (false, (3, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputAccessoryView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// inputAccessoryViewController
  UIInputViewController? get inputAccessoryViewController {
    objc.checkOsVersionInternal(
      'UIResponder.inputAccessoryViewController',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputAccessoryViewController,
    );
    return $ret.address == 0
        ? null
        : UIInputViewController.fromPointer($ret, retain: true, release: true);
  }

  /// inputAssistantItem
  UITextInputAssistantItem get inputAssistantItem {
    objc.checkOsVersionInternal(
      'UIResponder.inputAssistantItem',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputAssistantItem,
    );
    return UITextInputAssistantItem.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// inputView
  UIView? get inputView {
    objc.checkOsVersionInternal(
      'UIResponder.inputView',
      iOS: (false, (3, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputView);
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// inputViewController
  UIInputViewController? get inputViewController {
    objc.checkOsVersionInternal(
      'UIResponder.inputViewController',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputViewController,
    );
    return $ret.address == 0
        ? null
        : UIInputViewController.fromPointer($ret, retain: true, release: true);
  }

  /// reloadInputViews
  void reloadInputViews() {
    objc.checkOsVersionInternal(
      'UIResponder.reloadInputViews',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_reloadInputViews);
  }

  /// textInputContextIdentifier
  objc.NSString? get textInputContextIdentifier {
    objc.checkOsVersionInternal(
      'UIResponder.textInputContextIdentifier',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_textInputContextIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// textInputMode
  UITextInputMode? get textInputMode {
    objc.checkOsVersionInternal(
      'UIResponder.textInputMode',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textInputMode);
    return $ret.address == 0
        ? null
        : UITextInputMode.fromPointer($ret, retain: true, release: true);
  }

  /// clearTextInputContextIdentifier:
  static void clearTextInputContextIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UIResponder.clearTextInputContextIdentifier:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_UIResponder,
      _sel_clearTextInputContextIdentifier_,
      identifier.ref.pointer,
    );
  }
}

late final _sel_userActivity = objc.registerName("userActivity");
late final _sel_setUserActivity_ = objc.registerName("setUserActivity:");
late final _sel_updateUserActivityState_ = objc.registerName(
  "updateUserActivityState:",
);
late final _sel_restoreUserActivityState_ = objc.registerName(
  "restoreUserActivityState:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                NSUserActivity.fromPointer(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserActivity$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, NSUserActivity arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// ActivityContinuation
extension ActivityContinuation on UIResponder {
  /// restoreUserActivityState:
  void restoreUserActivityState(NSUserActivity userActivity) {
    objc.checkOsVersionInternal(
      'UIResponder.restoreUserActivityState:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_restoreUserActivityState_,
      userActivity.ref.pointer,
    );
  }

  /// setUserActivity:
  set userActivity(NSUserActivity? value) {
    objc.checkOsVersionInternal(
      'UIResponder.setUserActivity:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUserActivity_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// updateUserActivityState:
  void updateUserActivityState(NSUserActivity activity) {
    objc.checkOsVersionInternal(
      'UIResponder.updateUserActivityState:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_updateUserActivityState_,
      activity.ref.pointer,
    );
  }

  /// userActivity
  NSUserActivity? get userActivity {
    objc.checkOsVersionInternal(
      'UIResponder.userActivity',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_userActivity);
    return $ret.address == 0
        ? null
        : NSUserActivity.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIPasteConfiguration is a stub. To generate bindings for this class, include
/// UIPasteConfiguration in your config's objc-interfaces list.
///
/// UIPasteConfiguration
extension type UIPasteConfiguration._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [UIPasteConfiguration] that points to the same underlying object as [other].
  UIPasteConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIPasteConfiguration',
      iOS: (false, (11, 0, 0)),
    );
  }

  /// Constructs a [UIPasteConfiguration] that wraps the given raw object pointer.
  UIPasteConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIPasteConfiguration',
      iOS: (false, (11, 0, 0)),
    );
  }
}

late final _sel_pasteConfiguration = objc.registerName("pasteConfiguration");

/// Construction methods for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIPasteConfiguration_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIPasteConfiguration_ffiVoid$CallExtension
    on objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> {
  UIPasteConfiguration? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIPasteConfiguration.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setPasteConfiguration_ = objc.registerName(
  "setPasteConfiguration:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : UIPasteConfiguration.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIPasteConfiguration.fromPointer(
                arg1,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIPasteConfiguration.fromPointer(
                arg1,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIPasteConfiguration.fromPointer(
                arg1,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, UIPasteConfiguration? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_pasteItemProviders_ = objc.registerName("pasteItemProviders:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_canPasteItemProviders_ = objc.registerName(
  "canPasteItemProviders:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_bool_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  bool call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// UIPasteConfigurationSupporting
extension UIPasteConfigurationSupporting on UIResponder {
  /// canPasteItemProviders:
  bool canPasteItemProviders(objc.NSArray itemProviders) {
    objc.checkOsVersionInternal(
      'UIResponder.canPasteItemProviders:',
      iOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_canPasteItemProviders_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'canPasteItemProviders:',
      );
    }
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_canPasteItemProviders_,
      itemProviders.ref.pointer,
    );
  }

  /// pasteConfiguration
  UIPasteConfiguration? get pasteConfiguration {
    objc.checkOsVersionInternal(
      'UIResponder.pasteConfiguration',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_pasteConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIPasteConfiguration.fromPointer($ret, retain: true, release: true);
  }

  /// pasteItemProviders:
  void pasteItemProviders(objc.NSArray itemProviders) {
    objc.checkOsVersionInternal(
      'UIResponder.pasteItemProviders:',
      iOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_pasteItemProviders_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'pasteItemProviders:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pasteItemProviders_,
      itemProviders.ref.pointer,
    );
  }

  /// setPasteConfiguration:
  set pasteConfiguration(UIPasteConfiguration? value) {
    objc.checkOsVersionInternal(
      'UIResponder.setPasteConfiguration:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setPasteConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_captureTextFromCamera_ = objc.registerName(
  "captureTextFromCamera:",
);

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting on UIResponder {
  /// captureTextFromCamera:
  void captureTextFromCamera(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.captureTextFromCamera:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_captureTextFromCamera_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// WARNING: UIActivityItemsConfigurationReading is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationReading in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationReading
extension type UIActivityItemsConfigurationReading._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIActivityItemsConfigurationReading] that points to the same underlying object as [other].
  UIActivityItemsConfigurationReading.as(objc.ObjCObject other)
    : object$ = other;

  /// Constructs a [UIActivityItemsConfigurationReading] that wraps the given raw object pointer.
  UIActivityItemsConfigurationReading.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_activityItemsConfiguration = objc.registerName(
  "activityItemsConfiguration",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    UIActivityItemsConfigurationReading? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) =>
              fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
        > {
  UIActivityItemsConfigurationReading? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIActivityItemsConfigurationReading.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setActivityItemsConfiguration_ = objc.registerName(
  "setActivityItemsConfiguration:",
);

/// WARNING: UIActivityItemsConfigurationProviding is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationProviding in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationProviding
extension type UIActivityItemsConfigurationProviding._(
  objc.ObjCProtocol object$
)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIActivityItemsConfigurationProviding] that points to the same underlying object as [other].
  UIActivityItemsConfigurationProviding.as(objc.ObjCObject other)
    : object$ = other;

  /// Constructs a [UIActivityItemsConfigurationProviding] that wraps the given raw object pointer.
  UIActivityItemsConfigurationProviding.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIActivityItemsConfiguration
extension UIActivityItemsConfiguration on UIResponder {
  /// activityItemsConfiguration
  UIActivityItemsConfigurationReading? get activityItemsConfiguration {
    objc.checkOsVersionInternal(
      'UIResponder.activityItemsConfiguration',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_activityItemsConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIActivityItemsConfigurationReading.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// setActivityItemsConfiguration:
  set activityItemsConfiguration$1(UIActivityItemsConfigurationReading? value) {
    objc.checkOsVersionInternal(
      'UIResponder.setActivityItemsConfiguration:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setActivityItemsConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// UIResponder
extension type UIResponder._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, UIResponderStandardEditActions {
  /// Constructs a [UIResponder] that points to the same underlying object as [other].
  UIResponder.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIResponder] that wraps the given raw object pointer.
  UIResponder.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIResponder].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIResponder,
  );
}

extension UIResponder$Methods on UIResponder {}

enum UIDynamicItemCollisionBoundsType {
  UIDynamicItemCollisionBoundsTypeRectangle(0),
  UIDynamicItemCollisionBoundsTypeEllipse(1),
  UIDynamicItemCollisionBoundsTypePath(2);

  final int value;
  const UIDynamicItemCollisionBoundsType(this.value);

  static UIDynamicItemCollisionBoundsType fromValue(int value) =>
      switch (value) {
        0 => UIDynamicItemCollisionBoundsTypeRectangle,
        1 => UIDynamicItemCollisionBoundsTypeEllipse,
        2 => UIDynamicItemCollisionBoundsTypePath,
        _ => throw ArgumentError(
          'Unknown value for UIDynamicItemCollisionBoundsType: $value',
        ),
      };
}

enum UIInterfaceOrientation {
  UIInterfaceOrientationUnknown(0),
  UIInterfaceOrientationPortrait(1),
  UIInterfaceOrientationPortraitUpsideDown(2),
  UIInterfaceOrientationLandscapeLeft(4),
  UIInterfaceOrientationLandscapeRight(3);

  final int value;
  const UIInterfaceOrientation(this.value);

  static UIInterfaceOrientation fromValue(int value) => switch (value) {
    0 => UIInterfaceOrientationUnknown,
    1 => UIInterfaceOrientationPortrait,
    2 => UIInterfaceOrientationPortraitUpsideDown,
    4 => UIInterfaceOrientationLandscapeLeft,
    3 => UIInterfaceOrientationLandscapeRight,
    _ => throw ArgumentError(
      'Unknown value for UIInterfaceOrientation: $value',
    ),
  };
}

sealed class UIInterfaceOrientationMask {
  static const UIInterfaceOrientationMaskPortrait = 2;
  static const UIInterfaceOrientationMaskLandscapeLeft = 16;
  static const UIInterfaceOrientationMaskLandscapeRight = 8;
  static const UIInterfaceOrientationMaskPortraitUpsideDown = 4;
  static const UIInterfaceOrientationMaskLandscape = 24;
  static const UIInterfaceOrientationMaskAll = 30;
  static const UIInterfaceOrientationMaskAllButUpsideDown = 26;
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>`.
abstract final class ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  fromFunction(
    void Function(UITraitEnvironment, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            UITraitEnvironment.fromPointer(arg0, retain: true, release: true),
            UITraitCollection.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  listener(
    void Function(UITraitEnvironment, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITraitEnvironment.fromPointer(arg0, retain: false, release: true),
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  blocking(
    void Function(UITraitEnvironment, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITraitEnvironment.fromPointer(arg0, retain: false, release: true),
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITraitEnvironment.fromPointer(arg0, retain: false, release: true),
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>`.
extension ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
        > {
  void call(UITraitEnvironment arg0, UITraitCollection arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

enum UIFocusItemDeferralMode {
  UIFocusItemDeferralModeAutomatic(0),
  UIFocusItemDeferralModeAlways(1),
  UIFocusItemDeferralModeNever(2);

  final int value;
  const UIFocusItemDeferralMode(this.value);

  static UIFocusItemDeferralMode fromValue(int value) => switch (value) {
    0 => UIFocusItemDeferralModeAutomatic,
    1 => UIFocusItemDeferralModeAlways,
    2 => UIFocusItemDeferralModeNever,
    _ => throw ArgumentError(
      'Unknown value for UIFocusItemDeferralMode: $value',
    ),
  };
}

/// WARNING: UIFocusEnvironment is a stub. To generate bindings for this class, include
/// UIFocusEnvironment in your config's objc-protocols list.
///
/// UIFocusEnvironment
extension type UIFocusEnvironment._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIFocusEnvironment] that points to the same underlying object as [other].
  UIFocusEnvironment.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusEnvironment] that wraps the given raw object pointer.
  UIFocusEnvironment.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UITextAutocapitalizationType {
  UITextAutocapitalizationTypeNone(0),
  UITextAutocapitalizationTypeWords(1),
  UITextAutocapitalizationTypeSentences(2),
  UITextAutocapitalizationTypeAllCharacters(3);

  final int value;
  const UITextAutocapitalizationType(this.value);

  static UITextAutocapitalizationType fromValue(int value) => switch (value) {
    0 => UITextAutocapitalizationTypeNone,
    1 => UITextAutocapitalizationTypeWords,
    2 => UITextAutocapitalizationTypeSentences,
    3 => UITextAutocapitalizationTypeAllCharacters,
    _ => throw ArgumentError(
      'Unknown value for UITextAutocapitalizationType: $value',
    ),
  };
}

enum UITextAutocorrectionType {
  UITextAutocorrectionTypeDefault(0),
  UITextAutocorrectionTypeNo(1),
  UITextAutocorrectionTypeYes(2);

  final int value;
  const UITextAutocorrectionType(this.value);

  static UITextAutocorrectionType fromValue(int value) => switch (value) {
    0 => UITextAutocorrectionTypeDefault,
    1 => UITextAutocorrectionTypeNo,
    2 => UITextAutocorrectionTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextAutocorrectionType: $value',
    ),
  };
}

enum UITextSpellCheckingType {
  UITextSpellCheckingTypeDefault(0),
  UITextSpellCheckingTypeNo(1),
  UITextSpellCheckingTypeYes(2);

  final int value;
  const UITextSpellCheckingType(this.value);

  static UITextSpellCheckingType fromValue(int value) => switch (value) {
    0 => UITextSpellCheckingTypeDefault,
    1 => UITextSpellCheckingTypeNo,
    2 => UITextSpellCheckingTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextSpellCheckingType: $value',
    ),
  };
}

enum UITextSmartQuotesType {
  UITextSmartQuotesTypeDefault(0),
  UITextSmartQuotesTypeNo(1),
  UITextSmartQuotesTypeYes(2);

  final int value;
  const UITextSmartQuotesType(this.value);

  static UITextSmartQuotesType fromValue(int value) => switch (value) {
    0 => UITextSmartQuotesTypeDefault,
    1 => UITextSmartQuotesTypeNo,
    2 => UITextSmartQuotesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartQuotesType: $value'),
  };
}

enum UITextSmartDashesType {
  UITextSmartDashesTypeDefault(0),
  UITextSmartDashesTypeNo(1),
  UITextSmartDashesTypeYes(2);

  final int value;
  const UITextSmartDashesType(this.value);

  static UITextSmartDashesType fromValue(int value) => switch (value) {
    0 => UITextSmartDashesTypeDefault,
    1 => UITextSmartDashesTypeNo,
    2 => UITextSmartDashesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartDashesType: $value'),
  };
}

enum UITextSmartInsertDeleteType {
  UITextSmartInsertDeleteTypeDefault(0),
  UITextSmartInsertDeleteTypeNo(1),
  UITextSmartInsertDeleteTypeYes(2);

  final int value;
  const UITextSmartInsertDeleteType(this.value);

  static UITextSmartInsertDeleteType fromValue(int value) => switch (value) {
    0 => UITextSmartInsertDeleteTypeDefault,
    1 => UITextSmartInsertDeleteTypeNo,
    2 => UITextSmartInsertDeleteTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextSmartInsertDeleteType: $value',
    ),
  };
}

enum UITextInlinePredictionType {
  UITextInlinePredictionTypeDefault(0),
  UITextInlinePredictionTypeNo(1),
  UITextInlinePredictionTypeYes(2);

  final int value;
  const UITextInlinePredictionType(this.value);

  static UITextInlinePredictionType fromValue(int value) => switch (value) {
    0 => UITextInlinePredictionTypeDefault,
    1 => UITextInlinePredictionTypeNo,
    2 => UITextInlinePredictionTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextInlinePredictionType: $value',
    ),
  };
}

enum UITextMathExpressionCompletionType {
  UITextMathExpressionCompletionTypeDefault(0),
  UITextMathExpressionCompletionTypeNo(1),
  UITextMathExpressionCompletionTypeYes(2);

  final int value;
  const UITextMathExpressionCompletionType(this.value);

  static UITextMathExpressionCompletionType fromValue(int value) =>
      switch (value) {
        0 => UITextMathExpressionCompletionTypeDefault,
        1 => UITextMathExpressionCompletionTypeNo,
        2 => UITextMathExpressionCompletionTypeYes,
        _ => throw ArgumentError(
          'Unknown value for UITextMathExpressionCompletionType: $value',
        ),
      };
}

enum UIKeyboardType {
  UIKeyboardTypeDefault(0),
  UIKeyboardTypeASCIICapable(1),
  UIKeyboardTypeNumbersAndPunctuation(2),
  UIKeyboardTypeURL(3),
  UIKeyboardTypeNumberPad(4),
  UIKeyboardTypePhonePad(5),
  UIKeyboardTypeNamePhonePad(6),
  UIKeyboardTypeEmailAddress(7),
  UIKeyboardTypeDecimalPad(8),
  UIKeyboardTypeTwitter(9),
  UIKeyboardTypeWebSearch(10),
  UIKeyboardTypeASCIICapableNumberPad(11);

  static const UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable;

  final int value;
  const UIKeyboardType(this.value);

  static UIKeyboardType fromValue(int value) => switch (value) {
    0 => UIKeyboardTypeDefault,
    1 => UIKeyboardTypeASCIICapable,
    2 => UIKeyboardTypeNumbersAndPunctuation,
    3 => UIKeyboardTypeURL,
    4 => UIKeyboardTypeNumberPad,
    5 => UIKeyboardTypePhonePad,
    6 => UIKeyboardTypeNamePhonePad,
    7 => UIKeyboardTypeEmailAddress,
    8 => UIKeyboardTypeDecimalPad,
    9 => UIKeyboardTypeTwitter,
    10 => UIKeyboardTypeWebSearch,
    11 => UIKeyboardTypeASCIICapableNumberPad,
    _ => throw ArgumentError('Unknown value for UIKeyboardType: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardTypeASCIICapable)
      return "UIKeyboardType.UIKeyboardTypeASCIICapable, UIKeyboardType.UIKeyboardTypeAlphabet";
    return super.toString();
  }
}

enum UIKeyboardAppearance {
  UIKeyboardAppearanceDefault(0),
  UIKeyboardAppearanceDark(1),
  UIKeyboardAppearanceLight(2);

  static const UIKeyboardAppearanceAlert = UIKeyboardAppearanceDark;

  final int value;
  const UIKeyboardAppearance(this.value);

  static UIKeyboardAppearance fromValue(int value) => switch (value) {
    0 => UIKeyboardAppearanceDefault,
    1 => UIKeyboardAppearanceDark,
    2 => UIKeyboardAppearanceLight,
    _ => throw ArgumentError('Unknown value for UIKeyboardAppearance: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardAppearanceDark)
      return "UIKeyboardAppearance.UIKeyboardAppearanceDark, UIKeyboardAppearance.UIKeyboardAppearanceAlert";
    return super.toString();
  }
}

enum UIReturnKeyType {
  UIReturnKeyDefault(0),
  UIReturnKeyGo(1),
  UIReturnKeyGoogle(2),
  UIReturnKeyJoin(3),
  UIReturnKeyNext(4),
  UIReturnKeyRoute(5),
  UIReturnKeySearch(6),
  UIReturnKeySend(7),
  UIReturnKeyYahoo(8),
  UIReturnKeyDone(9),
  UIReturnKeyEmergencyCall(10),
  UIReturnKeyContinue(11);

  final int value;
  const UIReturnKeyType(this.value);

  static UIReturnKeyType fromValue(int value) => switch (value) {
    0 => UIReturnKeyDefault,
    1 => UIReturnKeyGo,
    2 => UIReturnKeyGoogle,
    3 => UIReturnKeyJoin,
    4 => UIReturnKeyNext,
    5 => UIReturnKeyRoute,
    6 => UIReturnKeySearch,
    7 => UIReturnKeySend,
    8 => UIReturnKeyYahoo,
    9 => UIReturnKeyDone,
    10 => UIReturnKeyEmergencyCall,
    11 => UIReturnKeyContinue,
    _ => throw ArgumentError('Unknown value for UIReturnKeyType: $value'),
  };
}

enum UIWritingToolsBehavior {
  UIWritingToolsBehaviorNone(-1),
  UIWritingToolsBehaviorDefault(0),
  UIWritingToolsBehaviorComplete(1),
  UIWritingToolsBehaviorLimited(2);

  final int value;
  const UIWritingToolsBehavior(this.value);

  static UIWritingToolsBehavior fromValue(int value) => switch (value) {
    -1 => UIWritingToolsBehaviorNone,
    0 => UIWritingToolsBehaviorDefault,
    1 => UIWritingToolsBehaviorComplete,
    2 => UIWritingToolsBehaviorLimited,
    _ => throw ArgumentError(
      'Unknown value for UIWritingToolsBehavior: $value',
    ),
  };
}

sealed class UIWritingToolsResultOptions {
  static const UIWritingToolsResultDefault = 0;
  static const UIWritingToolsResultPlainText = 1;
  static const UIWritingToolsResultRichText = 2;
  static const UIWritingToolsResultList = 4;
  static const UIWritingToolsResultTable = 8;
  static const UIWritingToolsResultPresentationIntent = 16;
}

enum UITextStorageDirection {
  UITextStorageDirectionForward(0),
  UITextStorageDirectionBackward(1);

  final int value;
  const UITextStorageDirection(this.value);

  static UITextStorageDirection fromValue(int value) => switch (value) {
    0 => UITextStorageDirectionForward,
    1 => UITextStorageDirectionBackward,
    _ => throw ArgumentError(
      'Unknown value for UITextStorageDirection: $value',
    ),
  };
}

enum UITextLayoutDirection {
  UITextLayoutDirectionRight(2),
  UITextLayoutDirectionLeft(3),
  UITextLayoutDirectionUp(4),
  UITextLayoutDirectionDown(5);

  final int value;
  const UITextLayoutDirection(this.value);

  static UITextLayoutDirection fromValue(int value) => switch (value) {
    2 => UITextLayoutDirectionRight,
    3 => UITextLayoutDirectionLeft,
    4 => UITextLayoutDirectionUp,
    5 => UITextLayoutDirectionDown,
    _ => throw ArgumentError('Unknown value for UITextLayoutDirection: $value'),
  };
}

enum UITextGranularity {
  UITextGranularityCharacter(0),
  UITextGranularityWord(1),
  UITextGranularitySentence(2),
  UITextGranularityParagraph(3),
  UITextGranularityLine(4),
  UITextGranularityDocument(5);

  final int value;
  const UITextGranularity(this.value);

  static UITextGranularity fromValue(int value) => switch (value) {
    0 => UITextGranularityCharacter,
    1 => UITextGranularityWord,
    2 => UITextGranularitySentence,
    3 => UITextGranularityParagraph,
    4 => UITextGranularityLine,
    5 => UITextGranularityDocument,
    _ => throw ArgumentError('Unknown value for UITextGranularity: $value'),
  };
}

enum UITextAlternativeStyle {
  UITextAlternativeStyleNone(0),
  UITextAlternativeStyleLowConfidence(1);

  final int value;
  const UITextAlternativeStyle(this.value);

  static UITextAlternativeStyle fromValue(int value) => switch (value) {
    0 => UITextAlternativeStyleNone,
    1 => UITextAlternativeStyleLowConfidence,
    _ => throw ArgumentError(
      'Unknown value for UITextAlternativeStyle: $value',
    ),
  };
}

/// WARNING: UITextInputDelegate is a stub. To generate bindings for this class, include
/// UITextInputDelegate in your config's objc-protocols list.
///
/// UITextInputDelegate
extension type UITextInputDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UITextInputDelegate] that points to the same underlying object as [other].
  UITextInputDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITextInputDelegate] that wraps the given raw object pointer.
  UITextInputDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UIViewAnimatingState {
  UIViewAnimatingStateInactive(0),
  UIViewAnimatingStateActive(1),
  UIViewAnimatingStateStopped(2);

  final int value;
  const UIViewAnimatingState(this.value);

  static UIViewAnimatingState fromValue(int value) => switch (value) {
    0 => UIViewAnimatingStateInactive,
    1 => UIViewAnimatingStateActive,
    2 => UIViewAnimatingStateStopped,
    _ => throw ArgumentError('Unknown value for UIViewAnimatingState: $value'),
  };
}

enum UIViewAnimatingPosition {
  UIViewAnimatingPositionEnd(0),
  UIViewAnimatingPositionStart(1),
  UIViewAnimatingPositionCurrent(2);

  final int value;
  const UIViewAnimatingPosition(this.value);

  static UIViewAnimatingPosition fromValue(int value) => switch (value) {
    0 => UIViewAnimatingPositionEnd,
    1 => UIViewAnimatingPositionStart,
    2 => UIViewAnimatingPositionCurrent,
    _ => throw ArgumentError(
      'Unknown value for UIViewAnimatingPosition: $value',
    ),
  };
}

enum UIModalPresentationStyle {
  UIModalPresentationFullScreen(0),
  UIModalPresentationPageSheet(1),
  UIModalPresentationFormSheet(2),
  UIModalPresentationCurrentContext(3),
  UIModalPresentationCustom(4),
  UIModalPresentationOverFullScreen(5),
  UIModalPresentationOverCurrentContext(6),
  UIModalPresentationPopover(7),
  UIModalPresentationBlurOverFullScreen(8),
  UIModalPresentationNone(-1),
  UIModalPresentationAutomatic(-2);

  final int value;
  const UIModalPresentationStyle(this.value);

  static UIModalPresentationStyle fromValue(int value) => switch (value) {
    0 => UIModalPresentationFullScreen,
    1 => UIModalPresentationPageSheet,
    2 => UIModalPresentationFormSheet,
    3 => UIModalPresentationCurrentContext,
    4 => UIModalPresentationCustom,
    5 => UIModalPresentationOverFullScreen,
    6 => UIModalPresentationOverCurrentContext,
    7 => UIModalPresentationPopover,
    8 => UIModalPresentationBlurOverFullScreen,
    -1 => UIModalPresentationNone,
    -2 => UIModalPresentationAutomatic,
    _ => throw ArgumentError(
      'Unknown value for UIModalPresentationStyle: $value',
    ),
  };
}

/// WARNING: UIContentContainer is a stub. To generate bindings for this class, include
/// UIContentContainer in your config's objc-protocols list.
///
/// UIContentContainer
extension type UIContentContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIContentContainer] that points to the same underlying object as [other].
  UIContentContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIContentContainer] that wraps the given raw object pointer.
  UIContentContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIViewController is a stub. To generate bindings for this class, include
/// UIViewController in your config's objc-interfaces list.
///
/// UIViewController
extension type UIViewController._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        UIResponder,
        objc.NSCoding,
        UIAppearanceContainer,
        UITraitEnvironment,
        UIContentContainer,
        UIFocusEnvironment {
  /// Constructs a [UIViewController] that points to the same underlying object as [other].
  UIViewController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewController', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIViewController] that wraps the given raw object pointer.
  UIViewController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewController', iOS: (false, (2, 0, 0)));
  }
}

enum UIGestureRecognizerState {
  UIGestureRecognizerStatePossible(0),
  UIGestureRecognizerStateBegan(1),
  UIGestureRecognizerStateChanged(2),
  UIGestureRecognizerStateEnded(3),
  UIGestureRecognizerStateCancelled(4),
  UIGestureRecognizerStateFailed(5);

  static const UIGestureRecognizerStateRecognized =
      UIGestureRecognizerStateEnded;

  final int value;
  const UIGestureRecognizerState(this.value);

  static UIGestureRecognizerState fromValue(int value) => switch (value) {
    0 => UIGestureRecognizerStatePossible,
    1 => UIGestureRecognizerStateBegan,
    2 => UIGestureRecognizerStateChanged,
    3 => UIGestureRecognizerStateEnded,
    4 => UIGestureRecognizerStateCancelled,
    5 => UIGestureRecognizerStateFailed,
    _ => throw ArgumentError(
      'Unknown value for UIGestureRecognizerState: $value',
    ),
  };

  @override
  String toString() {
    if (this == UIGestureRecognizerStateEnded)
      return "UIGestureRecognizerState.UIGestureRecognizerStateEnded, UIGestureRecognizerState.UIGestureRecognizerStateRecognized";
    return super.toString();
  }
}

enum UITimingCurveType {
  UITimingCurveTypeBuiltin(0),
  UITimingCurveTypeCubic(1),
  UITimingCurveTypeSpring(2),
  UITimingCurveTypeComposed(3);

  final int value;
  const UITimingCurveType(this.value);

  static UITimingCurveType fromValue(int value) => switch (value) {
    0 => UITimingCurveTypeBuiltin,
    1 => UITimingCurveTypeCubic,
    2 => UITimingCurveTypeSpring,
    3 => UITimingCurveTypeComposed,
    _ => throw ArgumentError('Unknown value for UITimingCurveType: $value'),
  };
}

/// WARNING: NSLayoutAnchor is a stub. To generate bindings for this class, include
/// NSLayoutAnchor in your config's objc-interfaces list.
///
/// NSLayoutAnchor
extension type NSLayoutAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSLayoutAnchor] that points to the same underlying object as [other].
  NSLayoutAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutAnchor] that wraps the given raw object pointer.
  NSLayoutAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

/// WARNING: UITrackingLayoutGuide is a stub. To generate bindings for this class, include
/// UITrackingLayoutGuide in your config's objc-interfaces list.
///
/// UITrackingLayoutGuide
extension type UITrackingLayoutGuide._(objc.ObjCObject object$)
    implements objc.ObjCObject, UILayoutGuide {
  /// Constructs a [UITrackingLayoutGuide] that points to the same underlying object as [other].
  UITrackingLayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UITrackingLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }

  /// Constructs a [UITrackingLayoutGuide] that wraps the given raw object pointer.
  UITrackingLayoutGuide.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UITrackingLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }
}

enum NSTextLayoutOrientation {
  NSTextLayoutOrientationHorizontal(0),
  NSTextLayoutOrientationVertical(1);

  final int value;
  const NSTextLayoutOrientation(this.value);

  static NSTextLayoutOrientation fromValue(int value) => switch (value) {
    0 => NSTextLayoutOrientationHorizontal,
    1 => NSTextLayoutOrientationVertical,
    _ => throw ArgumentError(
      'Unknown value for NSTextLayoutOrientation: $value',
    ),
  };
}

enum NSTextSelectionGranularity {
  NSTextSelectionGranularityCharacter(0),
  NSTextSelectionGranularityWord(1),
  NSTextSelectionGranularityParagraph(2),
  NSTextSelectionGranularityLine(3),
  NSTextSelectionGranularitySentence(4);

  final int value;
  const NSTextSelectionGranularity(this.value);

  static NSTextSelectionGranularity fromValue(int value) => switch (value) {
    0 => NSTextSelectionGranularityCharacter,
    1 => NSTextSelectionGranularityWord,
    2 => NSTextSelectionGranularityParagraph,
    3 => NSTextSelectionGranularityLine,
    4 => NSTextSelectionGranularitySentence,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionGranularity: $value',
    ),
  };
}

enum NSTextSelectionNavigationWritingDirection {
  NSTextSelectionNavigationWritingDirectionLeftToRight(0),
  NSTextSelectionNavigationWritingDirectionRightToLeft(1);

  final int value;
  const NSTextSelectionNavigationWritingDirection(this.value);

  static NSTextSelectionNavigationWritingDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationWritingDirectionLeftToRight,
        1 => NSTextSelectionNavigationWritingDirectionRightToLeft,
        _ => throw ArgumentError(
          'Unknown value for NSTextSelectionNavigationWritingDirection: $value',
        ),
      };
}

enum NSTextSelectionNavigationLayoutOrientation {
  NSTextSelectionNavigationLayoutOrientationHorizontal(0),
  NSTextSelectionNavigationLayoutOrientationVertical(1);

  final int value;
  const NSTextSelectionNavigationLayoutOrientation(this.value);

  static NSTextSelectionNavigationLayoutOrientation fromValue(
    int value,
  ) => switch (value) {
    0 => NSTextSelectionNavigationLayoutOrientationHorizontal,
    1 => NSTextSelectionNavigationLayoutOrientationVertical,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionNavigationLayoutOrientation: $value',
    ),
  };
}

/// WARNING: UIPrintFormatter$1 is a stub. To generate bindings for this class, include
/// UIPrintFormatter in your config's objc-interfaces list.
///
/// UIPrintFormatter
extension type UIPrintFormatter$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UIPrintFormatter$1] that points to the same underlying object as [other].
  UIPrintFormatter$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPrintFormatter', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UIPrintFormatter$1] that wraps the given raw object pointer.
  UIPrintFormatter$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPrintFormatter', iOS: (false, (4, 2, 0)));
  }
}

late final _class_CustomUIView = objc.getClass("CustomUIView");

/// CustomUIView
extension type CustomUIView._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIView {
  /// Constructs a [CustomUIView] that points to the same underlying object as [other].
  CustomUIView.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [CustomUIView] that wraps the given raw object pointer.
  CustomUIView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CustomUIView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CustomUIView,
  );
}

extension CustomUIView$Methods on CustomUIView {}
